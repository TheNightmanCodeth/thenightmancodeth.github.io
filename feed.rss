<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Joe's Blog</title><description>A cautionary tale on the horrors of programming ❤️</description><link>https://www.jdiggity.me</link><language>en</language><lastBuildDate>Wed, 17 Aug 2022 21:09:57 +0000</lastBuildDate><pubDate>Wed, 17 Aug 2022 21:09:57 +0000</pubDate><ttl>250</ttl><atom:link href="https://www.jdiggity.me/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.jdiggity.me/posts/ssg-comparison</guid><title>The Grimm Adventures of Choosing a Static Site Generator</title><description>How I struggled to find a static site generator with proper syntax highlighting and friendly templating</description><link>https://www.jdiggity.me/posts/ssg-comparison</link><pubDate>Sat, 13 Aug 2022 13:32:00 +0000</pubDate><content:encoded><![CDATA[<h1>The Grimm Adventures of Choosing a Static Site Generator</h1><p>I'm still new to this whole <em>technical blogging</em> thing. I've spent the majority of my time so far jumping between different static site generators when I should've been using that time to go back to 8th grade spelling and grammar.</p><p>I just wanted to find a generator that made me feel cool. <a href="">Publish</a>, for instance, made me feel super bleeding edge. It's a relatively young SSG; it's first commit was pushed in 2019! <a href="">Hugo</a> was another contender, since it's written in <code>go</code> and has a large and, most importantly, active userbase. I also tried out <a href="">VuePress</a>, which had me excited to use <code>vue.js</code> in my layouts.</p><p>Immediately, though, <code>publish</code> stood out to me. The other frameworks had me building page templates in raw HTML using different templating engines, but, <code>publish</code> let me create my layouts using <code>swift</code> in a very similar fashion to <code>swiftUI</code>. Just look at how cool <code>publish</code> is:</p><pre><code><span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    <span class="type">HTML</span> (
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: index, on: context.<span class="property">site</span>),
        .<span class="call">body</span> {
            <span class="type">SiteHeader</span>(context: context, selectedSelectionID: <span class="keyword">nil</span>)
            <span class="type">Wrapper</span> {
                <span class="type">H1</span>(index.<span class="property">title</span>)
                    .<span class="call">style</span>(<span class="string">"text-align: center;"</span>)
                <span class="type">Paragraph</span>(context.<span class="property">site</span>.<span class="property">description</span>)
                    .<span class="call">class</span>(<span class="string">"description"</span>)
                <span class="type">H2</span>(<span class="string">"Latest content"</span>)
                <span class="type">ItemList</span>(
                    items: context.<span class="call">allItems</span>(
                        sortedBy: \.<span class="property">date</span>,
                        order: .<span class="dotAccess">descending</span>
                    ),
                    site: context.<span class="property">site</span>
                )
            }
            <span class="type">SiteFooter</span>()
        }
    )
}
</code></pre><p>It's <em>extremely</em> approachable for someone who hasn't had the (great dis)pleasure of dealing with raw HTML/CSS in a long time. Of course, I still needed to make stylesheets with css, but it wasn't so bad!</p><h2>Publish</h2><p>As I stated earler, I <em>love</em> using <code>publish</code> for static site generation. I even posted a guide on using GitHub Actions to generate and deploy <code>publish</code> sites to GitHub Pages. You can check that out <a href="https://www.jdiggity.me/publish-ghactions">here</a> if you want.</p><p>But after fully committing and getting deep into the project I started to hit some roadblocks. The first of which I went over in my other post (linked above), but to recap I had no luck getting the built-in deploy functionality to work with GitHub Pages. Every time I tried publishing using the command line tool my terminal froze up while it was trying to push to the repo. I think the publish utility was meant to work only for people who have their codebase untracked on a local machine, or in a seperate repo. I took a look at the code and the publish function is basically just <code>cd</code>ing to the <code>Output</code> directory, initializing a git repo and trying to push. That didn't seem to work inside of an existing git repo.</p><p>The second (worst and final as well) issue I hit was a devastating lack of syntax highlighting. Programming is my entire blog. Every single post I make will include code snippets and sometimes those code snippets <em>aren't</em> swift. Publish comes with a pretty impressive syntax highlighting utility called <a href="https://github.com/johnsundell/splash">Splash</a>. It's really cool and works really well but, unfortunately, only for swift. Splash definitely has the potential to work with other languages. In fact, someone has added <a href="https://github.com/JZDesign/Splash/blob/kotlinGrammar2/Sources/Splash/Grammar/KoltinGrammar.swift">support for Kotlin</a>. The only problem is it takes a <strong>lot</strong> of work to add support for another language. You may call me lazy. You may say, "If you want support for other languages so bad why don't you add it yourself?" And to that I say:</p><h2>Creating a custom syntax highlighter for YAML using Splash</h2><p>I went ahead and gave it my all. I dug deep into the <a href="https://github.com/JohnSundell/Splash/blob/master/Sources/Splash/Grammar/SwiftGrammar.swift">swift grammar</a> and worked out how the original author implemented the Swift syntax highlighter. I won't bore you with the details, but it wasn't too bad. Too sum up, I created a new struct that implements <code>Grammar</code>. I defined a list of delimiters that basically tell the parser where each part of the code starts and stops. We then create several <code>SyntaxRule</code>s that are called when the parser reaches a new token.</p><p>Since <code>yaml</code> isn't exactly a programming language, it wasn't too difficult to create a highlighter for it. I simply created rules for comments that checks if the current line begins with a <code>#</code>, a string rule that's a little more complex, and rules for types and keywords that simply check if the current token is a part of a predefined list.</p><p>Here's what <code>YamlGrammar</code> wound up looking like:</p><pre><code><span class="keyword">public struct</span> YamlGrammar: <span class="type">Grammar</span> {
    <span class="keyword">public var</span> delimiters: <span class="type">CharacterSet</span>
    <span class="keyword">public var</span> syntaxRules: [<span class="type">SyntaxRule</span>]
    
    <span class="keyword">public init</span>() {
        <span class="keyword">var</span> delimiters = <span class="type">CharacterSet</span>.<span class="property">alphanumerics</span>.<span class="property">inverted</span>
        delimiters.<span class="call">remove</span>(<span class="string">"_"</span>)
        delimiters.<span class="call">remove</span>(<span class="string">"-"</span>)
        delimiters.<span class="call">remove</span>(<span class="string">"\"")</span>
        delimiters.<span class="call">remove</span>(<span class="string">"#"</span>)
        delimiters.<span class="call">remove</span>(<span class="string">"@"</span>)
        delimiters.<span class="call">remove</span>(<span class="string">"$"</span>)
        <span class="keyword">self</span>.<span class="property">delimiters</span> = delimiters
        
        syntaxRules = [
            <span class="type">KeywordRule</span>(),
            <span class="type">TypeRule</span>(),
            <span class="type">StringRule</span>(),
            <span class="type">CommentRule</span>(),
            <span class="type">NumberRule</span>()
        ]
    }
    
    <span class="keyword">public func</span> isDelimiter(<span class="keyword">_</span> delimiterA: <span class="type">Character</span>, mergableWith delimiterB: <span class="type">Character</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">switch</span> (delimiterA, delimiterB) {
        <span class="keyword">case</span> (<span class="keyword">_</span>, <span class="string">":"</span>):
            <span class="keyword">return false
        case</span> (<span class="string">":"</span>, <span class="string">"/"</span>):
            <span class="keyword">return true
        case</span> (<span class="string">":"</span>, <span class="keyword">_</span>):
            <span class="keyword">return false
        case</span> (<span class="string">"-"</span>, <span class="keyword">_</span>):
            <span class="keyword">return false
        case</span> (<span class="string">"#"</span>, <span class="keyword">_</span>):
            <span class="keyword">return false
        default</span>:
            <span class="keyword">return true</span>
        }
    }
}

<span class="keyword">private extension</span> <span class="type">YamlGrammar</span> {
    <span class="keyword">static let</span> keywords = ([
        <span class="string">"|"</span>, <span class="string">"---"</span>, <span class="string">"..."</span>, <span class="string">"&gt;"</span>, <span class="string">"["</span>, <span class="string">"]"</span>, <span class="string">"-"</span>
    ] <span class="keyword">as</span> <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)
    
    <span class="keyword">struct</span> CommentRule: <span class="type">SyntaxRule</span> {
        <span class="keyword">var</span> tokenType: <span class="type">TokenType</span> { <span class="keyword">return</span> .<span class="dotAccess">comment</span> }
        
        <span class="keyword">func</span> matches(<span class="keyword">_</span> segment: <span class="type">Segment</span>) -&gt; <span class="type">Bool</span> {
            <span class="keyword">if</span> segment.<span class="property">tokens</span>.<span class="property">onSameLine</span>.<span class="call">contains</span>(<span class="string">"#"</span>) {
                <span class="keyword">return true</span>
            }
            
            <span class="keyword">return</span> segment.<span class="property">tokens</span>.<span class="property">current</span>.<span class="call">hasPrefix</span>(<span class="string">"#"</span>)
        }
    }
    
    <span class="keyword">struct</span> StringRule: <span class="type">SyntaxRule</span> {
        <span class="keyword">var</span> tokenType: <span class="type">TokenType</span> { <span class="keyword">return</span> .<span class="dotAccess">string</span> }
        
        <span class="keyword">func</span> matches(<span class="keyword">_</span> segment: <span class="type">Segment</span>) -&gt; <span class="type">Bool</span> {
            <span class="keyword">if let</span> prev = segment.<span class="property">tokens</span>.<span class="property">previous</span> {
                <span class="comment">/**
                 *  In yaml files, quotes around strings are optional
                 *  Unless it's a number, a value following a colon or lines after a pipe (|) are considered a string
                 */</span>
                <span class="keyword">if</span> prev.<span class="call">hasSuffix</span>(<span class="string">":"</span>) {
                    <span class="keyword">if let</span> next = segment.<span class="property">tokens</span>.<span class="property">next</span> {
                        <span class="keyword">if</span> segment.<span class="property">tokens</span>.<span class="property">current</span>.<span class="call">hasSuffix</span>(<span class="string">":"</span>) &amp;&amp; next.<span class="call">hasSuffix</span>(<span class="string">":"</span>) {
                            <span class="comment">/**
                             * ie.
                             *  name:
                             *    name2: &lt;&lt; This is not a string
                             *      ...
                             */</span>
                            <span class="keyword">return false</span>
                        }
                        <span class="keyword">return true</span>
                    }
                } <span class="keyword">else</span> {
                    <span class="keyword">var</span> sameLine: <span class="type">Bool</span> = <span class="keyword">false</span>
                    segment.<span class="property">tokens</span>.<span class="property">onSameLine</span>.<span class="call">forEach</span>( { token <span class="keyword">in
                        if</span> token.<span class="call">hasSuffix</span>(<span class="string">":"</span>) {
                            sameLine = <span class="keyword">true</span>
                        }
                    })
                    <span class="keyword">if</span> sameLine {
                        <span class="keyword">return true</span>
                    }
                }
            }
            <span class="keyword">if</span> segment.<span class="property">tokens</span>.<span class="property">current</span> == <span class="string">":"</span> {
                <span class="keyword">return false</span>
            }
            <span class="keyword">return true</span>
        }
    }
    
    <span class="keyword">struct</span> NumberRule: <span class="type">SyntaxRule</span> {
        <span class="keyword">var</span> tokenType: <span class="type">TokenType</span> { <span class="keyword">return</span> .<span class="dotAccess">number</span> }
        
        <span class="keyword">func</span> matches(<span class="keyword">_</span> segment: <span class="type">Segment</span>) -&gt; <span class="type">Bool</span> {
            <span class="keyword">if</span> segment.<span class="property">tokens</span>.<span class="property">current</span>.<span class="property">isNumber</span> {
                <span class="keyword">return true</span>
            }
            
            <span class="keyword">guard</span> segment.<span class="property">tokens</span>.<span class="property">current</span> == <span class="string">"."</span> <span class="keyword">else</span> {
                <span class="keyword">return false</span>
            }
            
            <span class="keyword">guard let</span> prev = segment.<span class="property">tokens</span>.<span class="property">previous</span>, <span class="keyword">let</span> next = segment.<span class="property">tokens</span>.<span class="property">next</span> <span class="keyword">else</span> {
                <span class="keyword">return false</span>
            }
            
            <span class="keyword">return</span> prev.<span class="property">isNumber</span> &amp;&amp; next.<span class="property">isNumber</span>
        }
    }
    
    <span class="keyword">struct</span> KeywordRule: <span class="type">SyntaxRule</span> {
        <span class="keyword">var</span> tokenType: <span class="type">TokenType</span> { <span class="keyword">return</span> .<span class="dotAccess">keyword</span> }
        
        <span class="keyword">func</span> matches(<span class="keyword">_</span> segment: <span class="type">Segment</span>) -&gt; <span class="type">Bool</span> {
            <span class="keyword">return</span> keywords.<span class="call">contains</span>(segment.<span class="property">tokens</span>.<span class="property">current</span>)
        }
    }
    
    <span class="keyword">struct</span> TypeRule: <span class="type">SyntaxRule</span> {
        <span class="keyword">var</span> tokenType: <span class="type">TokenType</span> { <span class="keyword">return</span> .<span class="dotAccess">type</span> }
        
        <span class="keyword">func</span> matches(<span class="keyword">_</span> segment: <span class="type">Segment</span>) -&gt; <span class="type">Bool</span> {
            <span class="keyword">if let</span> next = segment.<span class="property">tokens</span>.<span class="property">next</span> {
                <span class="keyword">return</span> next.<span class="call">hasSuffix</span>(<span class="string">":"</span>)
            } <span class="keyword">else</span> {
                <span class="keyword">return false</span>
            }
        }
    }
}

<span class="keyword">extension</span> <span class="type">String</span>  {
    <span class="keyword">var</span> isNumber: <span class="type">Bool</span> {
        <span class="keyword">return</span> !isEmpty &amp;&amp; <span class="call">rangeOfCharacter</span>(from: <span class="type">CharacterSet</span>.<span class="property">decimalDigits</span>.<span class="property">inverted</span>) == <span class="keyword">nil</span>
    }
}
</code></pre><p>By far the hardest part was the string rule. This is because we don't actually have access to the previous line of code when we are checking the current token. Ideally, I would have gone back over the last tokens until I hit a <code>|</code> to confirm if the token was inside of a multiline comment. If iterating led us to a colon instead, the token is not inside of a multiline comment. Instead I had to cheat and essentially say if the token doesn't fit into anything else, it's a multiline string. I believe there is a better way to do this, but I haven't been able to work it out just yet.</p><p>So now we have our <code>yaml</code> grammar rules, what next? Well the official <code>SplashPublishPlugin</code> does not allow the use of custom <code>Grammar</code>s. I submitted a <a href="https://github.com/JohnSundell/SplashPublishPlugin/pull/8">pull request</a> on GitHub, but haven't gotten a response yet. Instead of waiting for that to be merged I went ahead and wrote my own implementation of the plugin.</p><p>It looks like this:</p><pre><code><span class="keyword">import</span> Publish
<span class="keyword">import</span> Splash
<span class="keyword">import</span> Ink

<span class="keyword">public extension</span> <span class="type">Plugin</span> {
    <span class="keyword">static func</span> splashPlugin(withClassPrefix classPrefix: <span class="type">String</span> = <span class="string">""</span>, withGrammars grammars: [(grammar: <span class="type">Grammar</span>, name: <span class="type">String</span>)] = [(<span class="type">SwiftGrammar</span>(), <span class="string">"swift"</span>)]) -&gt; <span class="type">Self</span> {
        <span class="type">Plugin</span>(name: <span class="string">"Splash"</span>) { context <span class="keyword">in</span>
            context.<span class="property">markdownParser</span>.<span class="call">addModifier</span>(.<span class="call">splashCodeBlocks</span>(withFormat: <span class="type">HTMLOutputFormat</span>(classPrefix: classPrefix), withGrammars: grammars)
            )
        }
    }
}

<span class="keyword">public extension</span> <span class="type">Modifier</span> {
    <span class="keyword">static func</span> splashCodeBlocks(withFormat format: <span class="type">HTMLOutputFormat</span> = .<span class="keyword">init</span>(), withGrammars grammars: [(grammar: <span class="type">Grammar</span>, name: <span class="type">String</span>)] = [(<span class="type">SwiftGrammar</span>(), <span class="string">"swift"</span>)]) -&gt; <span class="type">Self</span> {
        <span class="keyword">var</span> highlighter = <span class="type">SyntaxHighlighter</span>(format: format)
        <span class="keyword">return</span> <span class="type">Modifier</span>(target: .<span class="dotAccess">codeBlocks</span>) { html, md <span class="keyword">in
            var</span> markdown = md.<span class="call">dropFirst</span>(<span class="string">"```"</span>.<span class="property">count</span>)
            
            <span class="keyword">guard</span> !markdown.<span class="call">hasPrefix</span>(<span class="string">"no-highlight"</span>) <span class="keyword">else</span> {
                <span class="keyword">return</span> html
            }
            grammars.<span class="call">forEach</span>({ grammar, name <span class="keyword">in
                if</span> markdown.<span class="call">hasPrefix</span>(name) {
                    highlighter = <span class="type">SyntaxHighlighter</span>(format: format, grammar: grammar)
                }
            })
            
            markdown = markdown
                .<span class="call">drop</span>(while: { !$0.<span class="property">isNewline</span> })
                .<span class="call">dropFirst</span>()
                .<span class="call">dropLast</span>(<span class="string">"\n```"</span>.<span class="property">count</span>)
            
            <span class="keyword">let</span> highlighted = highlighter.<span class="call">highlight</span>(<span class="type">String</span>(markdown))
            <span class="keyword">return</span> <span class="string">"&lt;pre&gt;&lt;code&gt;"</span> + highlighted + <span class="string">"\n&lt;/code&gt;&lt;/pre&gt;"</span>
        }
    }
}
</code></pre><p>Almost exactly like the official plugin, with the addition of a <code>grammars</code> argument in the plugin method. The method takes a list of tuples that contain both a <code>Grammar</code> and the desired name of said grammar. Then, when applying the grammars, I loop through each of the provided tuples to see if this section matches up with any of the provided <code>name</code>s. If we find a match, we highlight that section using <code>SyntaxHighlighter</code> with the provided <code>grammar</code>.</p><p>This code goes into a swift file and is imported in my <code>main.swift</code> and used like so:</p><pre><code><span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(
    using: [
    .<span class="call">installPlugin</span>(
        .<span class="call">splashPlugin</span>(
            withClassPrefix: <span class="string">""</span>, 
            withGrammars: [
                (grammar: <span class="type">YamlGrammar</span>(), name: <span class="string">"yaml"</span>), 
                (grammar: <span class="type">SwiftGrammar</span>(), <span class="string">"swift"</span>)
            ]
        )
    ),
    .<span class="call">addMarkdownFiles</span>(),
    ...
    ]
)
</code></pre><p>And now both <code>yaml</code> and <code>swift</code> code blocks are syntax highlighted across my website!</p><p>Overall, getting <code>yaml</code> syntax highlighting wasn't too bad. I do worry, however, that adding a language like <code>golang</code> or <code>C++</code> might be a kind of monumental task.</p><p>For now, I'll be sticking mergableWith <code>publish</code>. If the day comes that I need syntax highlighting for a more complex language and I just can't work it out, I might need to look into switching to something like <code>hugo</code> that already has plugins that support a vast majority of languages.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.jdiggity.me/posts/publish-ghactions</guid><title>Using GitHub actions to deploy Publish sites to GitHub Pages</title><description>How to use GitHub Actions to deploy a static site built with Publish to GitHub Pages</description><link>https://www.jdiggity.me/posts/publish-ghactions</link><pubDate>Tue, 9 Aug 2022 18:32:00 +0000</pubDate><content:encoded><![CDATA[<h1>Using GitHub actions to deploy Publish sites to GitHub Pages</h1><p>I just spent a good few weeks looking for a good static site generator and in my journey found <a href="https://github.com/JohnSundell/Publish">Publish</a>. While this article isn’t about that, I highly recommend using Publish if you’re a Swift developer looking for a good static site generator!</p><p>While <code>Publish</code> comes with a built-in deployment function that works with GH Pages, <em>I</em> couldn't get it to work. It looks like it really only works if you’re deploying to a separate repository. Even then, a lot of us wish to automatically trigger a publish on each new blog post or git commit. I spent some time yesterday messing with GitHub Actions and put together a build script that can do just that.</p><h2>The Process</h2><p>I started off trying to simply spin up a macOS machine, cloning my repo, installing the <code>publish</code> command line tool from homebrew, generating the HTML and pushing that to my GitHub Pages branch.</p><p>This proved to be a bit of a hassle. GitHub actions uses a version of macOS that is too old to work with the publish command line tool that is available through homebrew.</p><p>“Okay,” I thought. “I’ll just build the command line tool from the source code.” Well, that didn’t work either. I was missing some swift concurrency libraries on the worker machine. That meant, I assume, the version of Swift on the GH Actions build machine was too old ☹️.</p><p>At this point I considered giving up, until I remembered Swift is cross platform! 🎉🎉</p><p>I set the runner to use <code>ubuntu-latest</code> instead of <code>macOS-latest</code> and got to thinking.</p><p>On Ubuntu the steps would be a bit different. First and foremost I’d need to install Swift. Luckily there exists an action on the GitHub Actions Marketplace called <a href="https://github.com/marketplace/actions/install-swift-on-linux"><code>Install Swift on Linux</code></a> which does just that: installs Swift on a Linux worker on Github Actions! Lucky day!</p><p>After Swift was installed I’d need to either get the <code>publish</code> command line tool building on Linux or figure out a way to build the project some other way. 🤞</p><p>Luckily (spoiler alert) the <code>publish</code> tool compiled and installed just fine on Ubuntu.</p><p>The last step was to push the resulting <code>Output</code> directory to my GitHub pages branch on my repo. Luckily there exists an awesome action on the GitHub Marketplace that makes doing that extremely easy. It’s called <a href="https://github.com/marketplace/actions/deploy-to-github-pages">Deploy to GitHub Pages</a> and it works like a charm!</p><p>Now that we’ve outlined the approach let’s get to making the workflow!</p><h2>Before we start...</h2><p>This will <em>not</em> be a GitHub Pages tutorial. In order to follow along here, you should already have GitHub Pages setup using one of your repos. You can check out the <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site">Creating a GitHub Pages Site</a> article for more info. Basically you'll create a new repository, name it <code>&lt;yourgithubusername&gt;.github.io</code> and configure the settings there.</p><h2>Creating the Workflow</h2><p>To get started creating the workflow we’ll open up a terminal and <code>cd</code> into our project’s root directory.</p><p>Once there, we create the directory <code>.github/workflows</code> and create a new file inside there called <code>main.yml</code>.</p><pre><code><span class="keyword">mkdir</span> <span class="type">-p</span> <span class="string">.github/workflows</span><br /><span class="keyword">touch</span> <span class="string">.github/workflows/main.yml</span></code></pre><p>Now we open up our favorite text editor and start configuring our workflow!</p><pre><code><span class="keyword">nvim</span> <span class="string">.github/workflows/main.yml</span></code></pre><p>First, we name our workflow:</p><pre><code><span class="type">name</span>: <span class="string">Deploy to GitHub Pages</span></code></pre><p>Next, we trigger the workflow when the branch with our source code receives a push. In my case, the source code for my blog is located on the <code>Publish</code> branch.</p><pre><code><span class="type">on</span>:<br />  <span class="type">push</span>:<br />    <span class="type">branches</span>: [ <span class="string">“Publish”</span> ]</code></pre><p>Finally we begin the actual workflow. First we tell the worker to use <code>ubuntu-latest</code> and use the marketplace action mentioned above to install the latest version of <code>Swift</code>.</p><pre><code><span class="type">jobs</span>:<br />  <span class="type">build</span>:<br />    <span class="type">runs-on</span>: <span class="string">ubuntu-latest</span><br />    <span class="type">steps</span>:<br />      - <span class="type">name</span>: <span class="string">Install Swift</span><br />        <span class="type">uses</span>: <span class="string">sersoft-gmbh/swifty-linux-action@v1</span><br />        <span class="type">with</span>:<br />          <span class="type">release-version</span>: <span class="string">5.6.2</span></code></pre><p>With our worker configured and swift installed we can move on to the next step: installing the <code>publish</code> command line tool.</p><p>Inside of the <code>steps</code> section we add the following:</p><pre><code>- <span class="type">name</span>: <span class="string">Install Publish</span><br />  <span class="type">run</span>: <span class="keyword">|</span><br /><span class="string">    git clone https://github.com/JohnSundell/Publish.git<br />    cd Publish<br />    make</span></code></pre><p>Now we can pull our repo to the worker and generate our static website!</p><pre><code>- <span class="type">uses</span>: <span class="string">actions/checkout@v3</span><br /><br />- <span class="type">name</span>: <span class="string">Generate site</span>
  <span class="type">run</span>: <span class="keyword">|</span><br /><span class="string">    cd $GITHUB_WORKSPACE/blog/<br />    publish generate</span></code></pre><p>A few things are going on here. First we use the <code>checkout</code> action from GitHub that pulls our repo from the branch that this <code>main.yml</code> is located on. The <code>checkout</code> action pulls the source code to <code>$GITHUB_WORKSPACE</code>, so we <code>cd</code> to that path. In my case, the source code is located inside of a subdirectory called <code>blog</code>, so I change directories to <code>$GITHUB_WORKSPACE/blog</code>. Once inside that directory we call <code>publish generate</code> to generate our static website.</p><p>Lastly we’ll use the <code>github-pages-deploy-action</code> to deploy our static site to our GitHub Pages branch!</p><pre><code><span class="keyword">-</span> <span class="type">name</span>: <span class="string">Deploy site</span>
  <span class="type">uses</span>: <span class="string">JamesIves/github-pages-deploy-action@v4</span>
    <span class="type">with</span>:
      <span class="type">branch</span>: <span class="string">master</span>
      <span class="type">folder</span>: <span class="string">blog/Output</span>
</code></pre><p>And just like that, our workflow is complete! In the last step we tell the <code>github-pages-deploy-action</code> which branch to deploy to, you might set this to <code>gh-pages</code> depending on your configuration. Then we tell it where our static site is located. In my case it’s located in the <code>Output</code> folder inside of the <code>blog</code> folder inside of the root of my repo. Yours might just be <code>folder: Output</code>.</p><p>After all of that, your <code>.github/workflows/main.yml</code> file should look something like this:</p><pre><code><span class="type">name</span>: <span class="string">Deploy to GHPages</span>

<span class="type">on</span>:
  <span class="type">push</span>:
    <span class="type">branches</span>: <span class="keyword">[</span> <span class="string">"Publish"</span> <span class="keyword">]</span>

<span class="type">jobs</span>:
  <span class="type">build</span>:
    <span class="type">runs-on</span>: <span class="string">ubuntu-latest</span>
    <span class="type">steps</span>:
      <span class="keyword">-</span> <span class="type">name</span>: <span class="string">Install Swift</span>
        <span class="type">uses</span>: <span class="string">sersoft-gmbh/swifty-linux-action@v1</span>
        <span class="type">with</span>:
          <span class="type">release-version</span>: <span class="string">5.6.2</span>

      <span class="keyword">-</span> <span class="type">name</span>: <span class="string">Install Publish</span>
        <span class="type">run</span>: <span class="keyword">|</span>
          <span class="string">git clone https://github.com/JohnSundell/Publish.git
          cd Publish
          make</span>

      <span class="keyword">-</span> <span class="type">uses</span>: <span class="string">actions/checkout@v3</span>

      <span class="keyword">-</span> <span class="type">name</span>: <span class="string">Generate site</span>
        <span class="type">run</span>: <span class="keyword">|</span>
          <span class="string">cd $GITHUB_WORKSPACE/blog/
          publish generate</span>

      <span class="keyword">-</span> <span class="type">name</span>: <span class="string">Publish site</span>
        <span class="type">uses</span>: <span class="string">JamesIves/github-pages-deploy-action@v4</span>
        <span class="type">with</span>:
          <span class="type">branch</span>: <span class="string">master</span>
          <span class="type">folder</span>: <span class="string">blog/Output</span>
</code></pre><p>Now commit and push that file to your repo and go to the <code>actions</code> tab.</p><img src="https://www.jdiggity.me/img/ghactions.png" alt="GitHub Actions"/>]]></content:encoded></item><item><guid isPermaLink="true">https://www.jdiggity.me/posts/mpc-1</guid><title>Using the Multipeer Connectivity Framework with SwiftUI 4</title><description>How I got the multipeer connectivity framework working with SwiftUI 4</description><link>https://www.jdiggity.me/posts/mpc-1</link><pubDate>Sun, 7 Aug 2022 18:32:00 +0000</pubDate><content:encoded><![CDATA[<h1>Using the Multipeer Connectivity Framework with SwiftUI 4</h1><p>Welcome to my first SwiftUI tutorial! In this one, I’m going to be demonstrating how to implement a basic Multipeer connectivity app that uses SwiftUI 4, no UIKit needed!</p><p>Without further ado, let’s begin!</p><p>The basic structure of our app will be as follows:</p><ul><li>A MultipeerSession object to handle pairing and communication with our paired peer</li><li>PairView will show the user a list of available peers and allow them to invite them to a game</li><li>GameView will display the game controls and show the user if they’ve won or lost</li></ul><p>The game will be a basic “Rock, Paper, Scissors” game. The users will pair up with each other, then they will be shown three options, rock, paper or scissors. When the user selects a move it will be sent to the opponent’s device, and once the timer is up the result will be shown.</p><p>With that basic overview out of the way, let’s dive into some code.</p><p>We’ll start by creating the MultipeerSession object. First, we need to import MultipeerConnectivity into our class and inherit NSObject and ObrvableObject.</p><pre><code><span class="keyword">class</span> RPSMultipeerSession: <span class="type">NSObject</span>, <span class="type">ObservableObject</span> {
    <span class="keyword">private let</span> serviceType = <span class="string">"rps-service"</span>
    <span class="keyword">private var</span> myPeerID: <span class="type">MCPeerID</span>
    
    <span class="keyword">public let</span> serviceAdvertiser: <span class="type">MCNearbyServiceAdvertiser</span>
    <span class="keyword">public let</span> serviceBrowser: <span class="type">MCNearbyServiceBrowser</span>
    <span class="keyword">public let</span> session: <span class="type">MCSession</span>
}
</code></pre><p>Here we create a <code>serviceType</code> string that will let other devices scanning for peers know that we are using the <code>RPS</code> app and are looking for <code>RPS</code> peers only. This string can be anything to distinguish our Multipeer service from others. We then create some instance variables that hold our <code>MCPeerID</code>, <code>MCNearbyServiceAdvertiser</code>, <code>MCNearbyServiceBrowser</code> and <code>MCSession</code>. These fields need to be made public so that we can perform operations with them outside of the <code>RPSMultipeerSession</code> class.</p><p>Inside of our object’s <code>init()</code> we will need to assign values to the variables we created above.</p><pre><code><span class="keyword">init</span>(username: <span class="type">String</span>) {
    myPeerID = <span class="type">MCPeerID</span>(displayName: username)
        
    session = <span class="type">MCSession</span>(peer: peerID, securityIdentity: <span class="keyword">nil</span>, encryptionPreference: .<span class="dotAccess">none</span>)
    serviceAdvertiser = <span class="type">MCNearbyServiceAdvertiser</span>(peer: peerID, discoveryInfo: <span class="keyword">nil</span>, serviceType: serviceType)
    serviceBrowser = <span class="type">MCNearbyServiceBrowser</span>(peer: peerID, serviceType: serviceType)
    <span class="keyword">super</span>.<span class="keyword">init</span>()
}
</code></pre><p>In our app, we’ll be allowing users to create a username to make discovery of peers easier. Here, we take the provided username as an argument in the initializer and create a <code>MCPeerID</code> from it.</p><p>Also inside of the initializer we create:</p><ul><li>session: Used for sending and receiving RPS moves</li><li>serviceAdvertiser: Used for advertising ourself to nearby players</li><li>serviceBrowser: Used for finding available players nearby</li></ul><p>And don’t forget to call <code>super.init()</code> to call the superclass’ init method!</p><p>Next, we need to consider how the data will be received from our peer. Later, we will create a delegate for our <code>session</code> object that will receive a <code>Data</code> object from our peer that we can then turn into something easier to work with. Since we only really have four options (rock, paper, scissors and none), we will be using an <code>enum</code> to make dealing with responses more readable and easier to work with. Something like this, placed inside of the same file as our <code>RPSMultipeerSession</code> class, will suffice:</p><pre><code><span class="keyword">enum</span> Move: <span class="type">String</span>, <span class="type">CaseIterable</span>, <span class="type">CustomStringConvertible</span> {
    <span class="keyword">case</span> rock, paper, scissors, unknown
    
    <span class="keyword">var</span> description : <span class="type">String</span> {
        <span class="keyword">switch self</span> {
        <span class="keyword">case</span> .<span class="dotAccess">rock</span>: <span class="keyword">return</span> <span class="string">"Rock"</span>
        <span class="keyword">case</span> .<span class="dotAccess">paper</span>: <span class="keyword">return</span> <span class="string">"Paper"</span>
        <span class="keyword">case</span> .<span class="dotAccess">scissors</span>: <span class="keyword">return</span> <span class="string">"Scissors"</span>
        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">"Thinking"</span>
        }
    }
}
</code></pre><p>Later on we will be using a <code>String</code> representation of our <code>Move</code> to display an image to our player. By using <code>CustomStringConvertible</code> we can reduce the amount of code needed to do just that.</p><p>Now that we have our <code>Move</code> enum created and usable, we should consider what type of data needs to be made available to our views. We know that our <code>PairView</code>, which will allow players to find and pair up with their friends, will need to have access to a list of currently available peers. That same view will need to know when we receive an invite from another player, as well as who that player is. The <code>GameView</code> will need to know when we receive a move from our opponent. More than one of our views might find it useful to know whether or not we are currently paired with a player and, lastly, our <code>PairView</code> will need to have some way of accepting or denying an invitation from another player.</p><pre><code><span class="keyword">@Published var</span> availablePeers: [<span class="type">MCPeerID</span>] = []
<span class="keyword">@Published var</span> receivedMove: <span class="type">Move</span> = .<span class="dotAccess">unknown</span>
<span class="keyword">@Published var</span> recvdInvite: <span class="type">Bool</span> = <span class="keyword">false
@Published var</span> recvdInviteFrom: <span class="type">MCPeerID</span>? = <span class="keyword">nil
@Published var</span> paired: <span class="type">Bool</span> = <span class="keyword">false
@Published var</span> invitationHandler: ((<span class="type">Bool</span>, <span class="type">MCSession</span>?) -&gt; <span class="type">Void</span>)?
</code></pre><p>All together, we will have six <code>@Published</code> properties in our <code>RPSMultipeerSession</code>. Making these variables <code>@Published</code> makes it so that our views can not only see the the value of the variable, but they can be notified when the values change.</p><p>With that out of the way, we need to create some delegates for our <code>session</code>, <code>serviceAdvertiser</code> and <code>serviceBrowser</code>. Let’s start with the longest one, <code>MCSessionDelegate</code>.</p><p>The session delegate has methods to handle:</p><ul><li>When a peer changes state (connected, disconnected, connecting)</li><li>When we receive <code>Data</code> from a peer</li><li>When we receive an <code>InputStream</code> from a peer</li><li>When we receive a <code>Resource</code> from a peer (with or without progress)</li><li>When we receive a certificate from a peer (authentication)</li></ul><p>We are really only concerned with two of these methods: when a peer changes state and when we receive <code>Data</code> from a user. Even though that is the case, each of these methods needs to be implemented inside of the delegate.</p><p>Swift has a neat feature called <code>extensions</code>. If you are unfamiliar, extensions essentially let you add code to any Swift class. One could create an <code>extension</code> on the <code>String</code> class to perform any kind of operation on a string. <code>Extension</code>s are extremely powerful and I highly recommend looking into the details but for now that should be a sufficient introduction to get us going.</p><p>To prevent our <code>RPSMultipeerSession</code> from getting too big to handle, we will utilize Swift’s <code>extension</code> to implement these delegates. We can simply do:</p><blockquote><p>extension RPSMultipeerSession: MCSessionDelegate</p></blockquote><p>and implement the delegate functions in there, outside of the main class but still in the same file. One could place these delegates into separate files, but I personally chose to keep them all inside of one file.</p><pre><code><span class="keyword">extension</span> <span class="type">RPSMultipeerSession</span>: <span class="type">MCSessionDelegate</span> {
    <span class="keyword">func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, peer peerID: <span class="type">MCPeerID</span>, didChange state: <span class="type">MCSessionState</span>) {
        log.<span class="call">info</span>(<span class="string">"peer</span> \(peerID) <span class="string">didChangeState:</span> \(state.<span class="property">rawValue</span>)<span class="string">"</span>)
        <span class="keyword">switch</span> state {
        <span class="keyword">case</span> <span class="type">MCSessionState</span>.<span class="property">notConnected</span>:
            <span class="comment">// Peer disconnected</span>
            <span class="keyword">break
        case</span> <span class="type">MCSessionState</span>.<span class="property">connected</span>:
            <span class="comment">// Peer connected</span>
            <span class="keyword">break
        default</span>:
            <span class="comment">// Peer connecting or something else</span>
            <span class="keyword">break</span>
        }
    }
    
    <span class="keyword">func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didReceive data: <span class="type">Data</span>, fromPeer peerID: <span class="type">MCPeerID</span>) {
        <span class="keyword">if let</span> string = <span class="type">String</span>(data: data, encoding: .<span class="dotAccess">utf8</span>), <span class="keyword">let</span> move = <span class="type">Move</span>(rawValue: string) {
            <span class="comment">// Received move from peer</span>
        } <span class="keyword">else</span> {
            log.<span class="call">info</span>(<span class="string">"didReceive invalid value</span> \(data.<span class="property">count</span>) <span class="string">bytes"</span>)
        }
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didReceive stream: <span class="type">InputStream</span>, withName streamName: <span class="type">String</span>, fromPeer peerID: <span class="type">MCPeerID</span>) {
        log.<span class="call">error</span>(<span class="string">"Receiving streams is not supported"</span>)
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didStartReceivingResourceWithName resourceName: <span class="type">String</span>, fromPeer peerID: <span class="type">MCPeerID</span>, with progress: <span class="type">Progress</span>) {
        log.<span class="call">error</span>(<span class="string">"Receiving resources is not supported"</span>)
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didFinishReceivingResourceWithName resourceName: <span class="type">String</span>, fromPeer peerID: <span class="type">MCPeerID</span>, at localURL: <span class="type">URL</span>?, withError error: <span class="type">Error</span>?) {
        log.<span class="call">error</span>(<span class="string">"Receiving resources is not supported"</span>)
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didReceiveCertificate certificate: [<span class="type">Any</span>]?, fromPeer peerID: <span class="type">MCPeerID</span>, certificateHandler: <span class="keyword">@escaping</span> (<span class="type">Bool</span>) -&gt; <span class="type">Void</span>) {
        <span class="call">certificateHandler</span>(<span class="keyword">true</span>)
    }
}
</code></pre><p>Like I said earlier, this is a <em>big</em> one. Make sure to use XCode’s autocomplete to get the functions declared.</p><p>As you can see, most of the functions simply print a line to the console and don’t actually do anything at all. This is because our app does not support sending or receiving streams or resources. This may change as the tutorial goes along, though (;</p><p>We’re not done, yet! If you’re following along with the code you’ve probably noticed that delegate doesn’t actually do anything at all. We need to implement the logic for responding to peer connectivity status changes and receiving data from our opponent. I will go in detail in part 2 on how to handle these events, so for now let’s move on.</p><p>Next we will implement the <code>MCNearbyServiceAdvertiserDelegate</code>. This one is a lot easier to digest:</p><pre><code><span class="keyword">extension</span> <span class="type">RPSMultipeerSession</span>: <span class="type">MCNearbyServiceAdvertiserDelegate</span> {
    <span class="keyword">func</span> advertiser(<span class="keyword">_</span> advertiser: <span class="type">MCNearbyServiceAdvertiser</span>, didNotStartAdvertisingPeer error: <span class="type">Error</span>) {
        log.<span class="call">error</span>(<span class="string">"ServiceAdvertiser didNotStartAdvertisingPeer:</span> \(<span class="type">String</span>(describing: error))<span class="string">"</span>)
    }
    
    <span class="keyword">func</span> advertiser(<span class="keyword">_</span> advertiser: <span class="type">MCNearbyServiceAdvertiser</span>, didReceiveInvitationFromPeer peerID: <span class="type">MCPeerID</span>, withContext context: <span class="type">Data</span>?, invitationHandler: <span class="keyword">@escaping</span> (<span class="type">Bool</span>, <span class="type">MCSession</span>?) -&gt; <span class="type">Void</span>) {
        log.<span class="call">info</span>(<span class="string">"didReceiveInvitationFromPeer</span> \(peerID)<span class="string">"</span>)
    }
}
</code></pre><p>The service advertiser has two methods: one is called when the advertiser can’t start advertising for some reason and the other when we receive an invitation from another player. The latter will be implemented, again, in part 2! Last but not least we need to implement the <code>MCNearbyServiceBrowserDelegate</code>.</p><pre><code><span class="keyword">extension</span> <span class="type">RPSMultipeerSession</span>: <span class="type">MCNearbyServiceBrowserDelegate</span> {
    <span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, didNotStartBrowsingForPeers error: <span class="type">Error</span>) {
        <span class="comment">//TODO: Tell the user something went wrong and try again</span>
        log.<span class="call">error</span>(<span class="string">"ServiceBroser didNotStartBrowsingForPeers:</span> \(<span class="type">String</span>(describing: error))<span class="string">"</span>)
    }
    
    <span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, foundPeer peerID: <span class="type">MCPeerID</span>, withDiscoveryInfo info: [<span class="type">String</span> : <span class="type">String</span>]?) {
        log.<span class="call">info</span>(<span class="string">"ServiceBrowser found peer:</span> \(peerID)<span class="string">"</span>)
        <span class="comment">// Add the peer to the list of available peers</span>
    }
    
    <span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, lostPeer peerID: <span class="type">MCPeerID</span>) {
        log.<span class="call">info</span>(<span class="string">"ServiceBrowser lost peer:</span> \(peerID)<span class="string">"</span>)
        <span class="comment">// Remove lost peer from list of available peers</span>
    }
}
</code></pre><p>This delegate has methods that are called when:</p><ul><li>The browser does not start browsing for some reason</li><li>The browser found a nearby peer that is advertising our serviceType</li><li>The browser lost a nearby peer that was advertising our serviceType</li></ul><p>Now that we have our delegates setup we can apply them to our <code>session</code>, <code>serviceAdvertiser</code> and <code>serviceBrowser</code>.</p><pre><code>session.<span class="property">delegate</span> = <span class="keyword">self</span>
serviceAdvertiser.<span class="property">delegate</span> = <span class="keyword">self</span>
serviceBrowser.<span class="property">delegate</span> = <span class="keyword">self</span>
                
serviceAdvertiser.<span class="call">startAdvertisingPeer</span>()
serviceBrowser.<span class="call">startBrowsingForPeers</span>()
</code></pre><p>We add this inside of our <code>init()</code> after the call to <code>super.init()</code>. This assigns the delegates and starts advertising and browsing to/for peers. We’re almost done, but we can’t forget to tell our advertiser and browser to stop inside of <code>deinit()</code>.</p><pre><code><span class="keyword">deinit</span> {
    serviceAdvertiser.<span class="call">stopAdvertisingPeer</span>()
    serviceBrowser.<span class="call">stopBrowsingForPeers</span>()
}
</code></pre><p>Now that we have all of this done, our <code>RPSMultipeerSession.swift</code> file should look like this:</p><pre><code><span class="comment">//
//  RPSMultipeerSession.swift
//  RPS
//
//  Created by Joe Diragi on 7/28/22.
//</span>

<span class="keyword">import</span> MultipeerConnectivity
<span class="keyword">import</span> os

<span class="keyword">enum</span> Move: <span class="type">String</span>, <span class="type">CaseIterable</span>, <span class="type">CustomStringConvertible</span> {
    <span class="keyword">case</span> rock, paper, scissors, unknown
    
    <span class="keyword">var</span> description : <span class="type">String</span> {
        <span class="keyword">switch self</span> {
        <span class="keyword">case</span> .<span class="dotAccess">rock</span>: <span class="keyword">return</span> <span class="string">"Rock"</span>
        <span class="keyword">case</span> .<span class="dotAccess">paper</span>: <span class="keyword">return</span> <span class="string">"Paper"</span>
        <span class="keyword">case</span> .<span class="dotAccess">scissors</span>: <span class="keyword">return</span> <span class="string">"Scissors"</span>
        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">"Thinking"</span>
        }
      }
}

<span class="keyword">class</span> RPSMultipeerSession: <span class="type">NSObject</span>, <span class="type">ObservableObject</span> {
    <span class="keyword">private let</span> serviceType = <span class="string">"rps-service"</span>
    <span class="keyword">private var</span> myPeerID: <span class="type">MCPeerID</span>
    
    <span class="keyword">public let</span> serviceAdvertiser: <span class="type">MCNearbyServiceAdvertiser</span>
    <span class="keyword">public let</span> serviceBrowser: <span class="type">MCNearbyServiceBrowser</span>
    <span class="keyword">public let</span> session: <span class="type">MCSession</span>
        
    <span class="keyword">private let</span> log = <span class="type">Logger</span>()
    
    <span class="keyword">@Published var</span> availablePeers: [<span class="type">MCPeerID</span>] = []
    <span class="keyword">@Published var</span> receivedMove: <span class="type">Move</span> = .<span class="dotAccess">unknown</span>
    <span class="keyword">@Published var</span> recvdInvite: <span class="type">Bool</span> = <span class="keyword">false
    @Published var</span> recvdInviteFrom: <span class="type">MCPeerID</span>? = <span class="keyword">nil
    @Published var</span> paired: <span class="type">Bool</span> = <span class="keyword">false
    @Published var</span> invitationHandler: ((<span class="type">Bool</span>, <span class="type">MCSession</span>?) -&gt; <span class="type">Void</span>)?
    
    <span class="keyword">init</span>(username: <span class="type">String</span>) {
        <span class="keyword">let</span> peerID = <span class="type">MCPeerID</span>(displayName: username)
        <span class="keyword">self</span>.<span class="property">myPeerID</span> = peerID
        
        session = <span class="type">MCSession</span>(peer: peerID, securityIdentity: <span class="keyword">nil</span>, encryptionPreference: .<span class="dotAccess">none</span>)
        serviceAdvertiser = <span class="type">MCNearbyServiceAdvertiser</span>(peer: peerID, discoveryInfo: <span class="keyword">nil</span>, serviceType: serviceType)
        serviceBrowser = <span class="type">MCNearbyServiceBrowser</span>(peer: peerID, serviceType: serviceType)
        <span class="keyword">super</span>.<span class="keyword">init</span>()
        
        session.<span class="property">delegate</span> = <span class="keyword">self</span>
        serviceAdvertiser.<span class="property">delegate</span> = <span class="keyword">self</span>
        serviceBrowser.<span class="property">delegate</span> = <span class="keyword">self</span>
                
        serviceAdvertiser.<span class="call">startAdvertisingPeer</span>()
        serviceBrowser.<span class="call">startBrowsingForPeers</span>()
    }
    
    <span class="keyword">deinit</span> {
        serviceAdvertiser.<span class="call">stopAdvertisingPeer</span>()
        serviceBrowser.<span class="call">stopBrowsingForPeers</span>()
    }
}

<span class="keyword">extension</span> <span class="type">RPSMultipeerSession</span>: <span class="type">MCSessionDelegate</span> {
    <span class="keyword">func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, peer peerID: <span class="type">MCPeerID</span>, didChange state: <span class="type">MCSessionState</span>) {
        log.<span class="call">info</span>(<span class="string">"peer</span> \(peerID) <span class="string">didChangeState:</span> \(state.<span class="property">rawValue</span>)<span class="string">"</span>)
        <span class="keyword">switch</span> state {
        <span class="keyword">case</span> <span class="type">MCSessionState</span>.<span class="property">notConnected</span>:
            <span class="comment">// Peer disconnected</span>
            <span class="keyword">break
        case</span> <span class="type">MCSessionState</span>.<span class="property">connected</span>:
            <span class="comment">// Peer connected</span>
            <span class="keyword">break
        default</span>:
            <span class="comment">// Peer connecting or something else</span>
            <span class="keyword">break</span>
        }
    }
    
    <span class="keyword">func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didReceive data: <span class="type">Data</span>, fromPeer peerID: <span class="type">MCPeerID</span>) {
        <span class="keyword">if let</span> string = <span class="type">String</span>(data: data, encoding: .<span class="dotAccess">utf8</span>), <span class="keyword">let</span> move = <span class="type">Move</span>(rawValue: string) {
            <span class="comment">// Received move from peer</span>
        } <span class="keyword">else</span> {
            log.<span class="call">info</span>(<span class="string">"didReceive invalid value</span> \(data.<span class="property">count</span>) <span class="string">bytes"</span>)
        }
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didReceive stream: <span class="type">InputStream</span>, withName streamName: <span class="type">String</span>, fromPeer peerID: <span class="type">MCPeerID</span>) {
        log.<span class="call">error</span>(<span class="string">"Receiving streams is not supported"</span>)
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didStartReceivingResourceWithName resourceName: <span class="type">String</span>, fromPeer peerID: <span class="type">MCPeerID</span>, with progress: <span class="type">Progress</span>) {
        log.<span class="call">error</span>(<span class="string">"Receiving resources is not supported"</span>)
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didFinishReceivingResourceWithName resourceName: <span class="type">String</span>, fromPeer peerID: <span class="type">MCPeerID</span>, at localURL: <span class="type">URL</span>?, withError error: <span class="type">Error</span>?) {
        log.<span class="call">error</span>(<span class="string">"Receiving resources is not supported"</span>)
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didReceiveCertificate certificate: [<span class="type">Any</span>]?, fromPeer peerID: <span class="type">MCPeerID</span>, certificateHandler: <span class="keyword">@escaping</span> (<span class="type">Bool</span>) -&gt; <span class="type">Void</span>) {
        <span class="call">certificateHandler</span>(<span class="keyword">true</span>)
    }
}

<span class="keyword">extension</span> <span class="type">RPSMultipeerSession</span>: <span class="type">MCNearbyServiceAdvertiserDelegate</span> {
    <span class="keyword">func</span> advertiser(<span class="keyword">_</span> advertiser: <span class="type">MCNearbyServiceAdvertiser</span>, didNotStartAdvertisingPeer error: <span class="type">Error</span>) {
        log.<span class="call">error</span>(<span class="string">"ServiceAdvertiser didNotStartAdvertisingPeer:</span> \(<span class="type">String</span>(describing: error))<span class="string">"</span>)
    }
    
    <span class="keyword">func</span> advertiser(<span class="keyword">_</span> advertiser: <span class="type">MCNearbyServiceAdvertiser</span>, didReceiveInvitationFromPeer peerID: <span class="type">MCPeerID</span>, withContext context: <span class="type">Data</span>?, invitationHandler: <span class="keyword">@escaping</span> (<span class="type">Bool</span>, <span class="type">MCSession</span>?) -&gt; <span class="type">Void</span>) {
        log.<span class="call">info</span>(<span class="string">"didReceiveInvitationFromPeer</span> \(peerID)<span class="string">"</span>)
    }
}

<span class="keyword">extension</span> <span class="type">RPSMultipeerSession</span>: <span class="type">MCNearbyServiceBrowserDelegate</span> {
    <span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, didNotStartBrowsingForPeers error: <span class="type">Error</span>) {
        <span class="comment">//TODO: Tell the user something went wrong and try again</span>
        log.<span class="call">error</span>(<span class="string">"ServiceBroser didNotStartBrowsingForPeers:</span> \(<span class="type">String</span>(describing: error))<span class="string">"</span>)
    }
    
    <span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, foundPeer peerID: <span class="type">MCPeerID</span>, withDiscoveryInfo info: [<span class="type">String</span> : <span class="type">String</span>]?) {
        log.<span class="call">info</span>(<span class="string">"ServiceBrowser found peer:</span> \(peerID)<span class="string">"</span>)
        <span class="comment">// Add the peer to the list of available peers</span>
    }
    
    <span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, lostPeer peerID: <span class="type">MCPeerID</span>) {
        log.<span class="call">info</span>(<span class="string">"ServiceBrowser lost peer:</span> \(peerID)<span class="string">"</span>)
        <span class="comment">// Remove lost peer from list of available peers</span>
    }
}
</code></pre><p><a href="https://github.com/TheNightmanCodeth/RPS">Don't forget to check out the GitHub repo!</a></p><p><a href="https://www.jdiggity.me/mpc-2">Continue to part 2</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.jdiggity.me/posts/mpc-2</guid><title>mpc-2</title><description>How I got the multipeer connectivity framework working with SwiftUI 4 - Part 2</description><link>https://www.jdiggity.me/posts/mpc-2</link><pubDate>Sun, 7 Aug 2022 18:32:00 +0000</pubDate><content:encoded><![CDATA[<p>In (part 1)[/mpc-1] we created a skeleton RPSMultipeerSession to communicate from one device to another directly using only the multipeer connectivity framework, no backend server was used at all. In this part we will finish implementing those methods and start building the UI! To start, we need a way to send our move to our opponent. Inside of the RPSMultipeerSession class, after deinit(), we will place this method:</p><pre><code><span class="keyword">func</span> send(move: <span class="type">Move</span>) {
    <span class="keyword">if</span> !session.<span class="property">connectedPeers</span>.<span class="property">isEmpty</span> {
        log.<span class="call">info</span>(<span class="string">"sendMove:</span> \(<span class="type">String</span>(describing: move)) <span class="string">to</span> \(<span class="keyword">self</span>.<span class="property">session</span>.<span class="property">connectedPeers</span>[<span class="number">0</span>].displayName)<span class="string">"</span>)
        <span class="keyword">do</span> {
            <span class="keyword">try</span> session.<span class="call">send</span>(move.<span class="property">rawValue</span>.<span class="call">data</span>(using: .<span class="dotAccess">utf8</span>)!, toPeers: session.<span class="property">connectedPeers</span>, with: .<span class="dotAccess">reliable</span>)
        } <span class="keyword">catch</span> {
            log.<span class="call">error</span>(<span class="string">"Error sending:</span> \(<span class="type">String</span>(describing: error))<span class="string">"</span>)
        }
    }
}
</code></pre><p>First we ensure our opponent is connected by checking if session.connectedPeers is empty. If it isn't empty, we have an opponent connected and waiting to receive our move. We try and send the move provided using session.send() and catch any exceptions thrown. With the send method implemented we can move on to finishing up the delegates. Inside of the MCSessionDelegate, there is a switch statement that handles the state of the peer whose state has changed. If the peer has disconnected, we should make our paired variable false and start looking for another opponent. If the peer has connected, we set our paired variable to true and stop looking for peers. If something else happened, most likely the peer is currently connecting, and therefore our paired variable should be false. The implementation looks like this:</p><pre><code><span class="keyword">switch</span> state {
<span class="keyword">case</span> <span class="type">MCSessionState</span>.<span class="property">notConnected</span>:
    <span class="comment">// Peer disconnected</span>
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        <span class="keyword">self</span>.<span class="property">paired</span> = <span class="keyword">false</span>
    }
    <span class="comment">// Peer disconnected, start accepting invitaions again</span>
    serviceAdvertiser.<span class="call">startAdvertisingPeer</span>()
    <span class="keyword">break
case</span> <span class="type">MCSessionState</span>.<span class="property">connected</span>:
    <span class="comment">// Peer connected</span>
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        <span class="keyword">self</span>.<span class="property">paired</span> = <span class="keyword">true</span>
    }
    <span class="comment">// We are paired, stop accepting invitations</span>
    serviceAdvertiser.<span class="call">stopAdvertisingPeer</span>()
    <span class="keyword">break
default</span>:
    <span class="comment">// Peer connecting or something else</span>
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        <span class="keyword">self</span>.<span class="property">paired</span> = <span class="keyword">false</span>
    }
    <span class="keyword">break</span>
}
</code></pre><p>Since paired is a published variable and we will have views listening for changes we need to make our changes on the main thread, hence DispatchQueue.main.async is used. Still in the MCSessionDelegate, the didReceive data: method is next. When we receive a message from our opponent we should tell the view that we received a move and what that move is. The implementation would look like this:</p><pre><code><span class="keyword">func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didReceive data: <span class="type">Data</span>, fromPeer peerID: <span class="type">MCPeerID</span>) {
    <span class="keyword">if let</span> string = <span class="type">String</span>(data: data, encoding: .<span class="dotAccess">utf8</span>), <span class="keyword">let</span> move = <span class="type">Move</span>(rawValue: string) {
        log.<span class="call">info</span>(<span class="string">"didReceive move</span> \(string)<span class="string">"</span>)
        <span class="comment">// We received a move from the opponent, tell the GameView</span>
        <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
            <span class="keyword">self</span>.<span class="property">receivedMove</span> = move
        }
    } <span class="keyword">else</span> {
        log.<span class="call">info</span>(<span class="string">"didReceive invalid value</span> \(data.<span class="property">count</span>) <span class="string">bytes"</span>)
    }
}
</code></pre><p>Here we make sure we can create a Move from the data we received and, if we can, we update, on the main thread, the value of receivedMove. The rest of this delegate can be left the way it is. Inside of the MCNearbyServiceAdvertiserDelegate, there is one method that needs to be completed. It's the didReceiveInvitationFromPeer one and the implementation looks like this:</p><pre><code><span class="keyword">func</span> advertiser(<span class="keyword">_</span> advertiser: <span class="type">MCNearbyServiceAdvertiser</span>, didReceiveInvitationFromPeer peerID: <span class="type">MCPeerID</span>, withContext context: <span class="type">Data</span>?, invitationHandler: <span class="keyword">@escaping</span> (<span class="type">Bool</span>, <span class="type">MCSession</span>?) -&gt; <span class="type">Void</span>) {
    log.<span class="call">info</span>(<span class="string">"didReceiveInvitationFromPeer</span> \(peerID)<span class="string">"</span>)
    
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        <span class="comment">// Tell PairView to show the invitation alert</span>
        <span class="keyword">self</span>.<span class="property">recvdInvite</span> = <span class="keyword">true</span>
        <span class="comment">// Give PairView the peerID of the peer who invited us</span>
        <span class="keyword">self</span>.<span class="property">recvdInviteFrom</span> = peerID
        <span class="comment">// Give PairView the `invitationHandler` so it can accept/deny the invitation</span>
        <span class="keyword">self</span>.<span class="property">invitationHandler</span> = invitationHandler
    }
}
</code></pre><p>When we receive an invitation from another player we want to let our view know so it can prompt our user to accept or reject the invitation. We tell our view we received an invite, who invited us and give it an invitationHandler to respond to the other player with. Next we will finish up the MCNearbyServiceBrowserDelegate. When the browser finds a peer we want to add it to availablePeers so our view can show it to our user. The implementation looks like this:</p><pre><code><span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, foundPeer peerID: <span class="type">MCPeerID</span>, withDiscoveryInfo info: [<span class="type">String</span> : <span class="type">String</span>]?) {
    log.<span class="call">info</span>(<span class="string">"ServiceBrowser found peer:</span> \(peerID)<span class="string">"</span>)
    <span class="comment">// Add the peer to the list of available peers</span>
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        <span class="keyword">self</span>.<span class="property">availablePeers</span>.<span class="call">append</span>(peerID)
    }
}
</code></pre><p>We simply append the peerID to availablePeers on the main thread. Easy, right? And our last bit of missing code is inside of the lostPeer browser method. When a peer is lost, it should be removed from availablePeers, like so:</p><pre><code><span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, lostPeer peerID: <span class="type">MCPeerID</span>) {
    log.<span class="call">info</span>(<span class="string">"ServiceBrowser lost peer:</span> \(peerID)<span class="string">"</span>)
    <span class="comment">// Remove lost peer from list of available peers</span>
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        <span class="keyword">self</span>.<span class="property">availablePeers</span>.<span class="call">removeAll</span>(where: {
            $0 == peerID
        })
    }
}
</code></pre><p>And that wraps up our RPSMultipeerSession! Now we move on to creating the UI and dealing with these data. In UI land, we need to create a starting view to allow our user to set his/her username. This can be done in many ways, but once the text is received we should use a NavigationLink or similar to move on to the pairing screen.</p><pre><code><span class="type">NavigationLink</span>(destination: <span class="type">PairView</span>(rpsSession: <span class="type">RPSMultipeerSession</span>(username: username))) {
    <span class="type">Image</span>(systemName: <span class="string">"arrow.right.circle.fill"</span>)
        .<span class="call">foregroundColor</span>(<span class="type">Color</span>(.<span class="dotAccess">gray</span>))
}
</code></pre><p>This is how I did it, passing the username into the RPSMultipeerSession as an argument for the PairView. If our session object's paired property is false, the PairView will display a list of buttons with the username of players nearby who are also on the PairView. When the user clicks one of the buttons, an invitation will be sent to that user and an alert will be shown prompting the player to accept or reject the invitation. Here's how that would look:</p><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">import</span> os

<span class="keyword">struct</span> PairView: <span class="type">View</span> {
    <span class="keyword">@StateObject var</span> rpsSession: <span class="type">RPSMultipeerSession</span>
    <span class="keyword">var</span> logger = <span class="type">Logger</span>()
        
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">if</span> (!rpsSession.<span class="property">paired</span>) {
            <span class="type">HStack</span> {
                <span class="type">List</span>(rpsSession.<span class="property">availablePeers</span>, id: \.<span class="keyword">self</span>) { peer <span class="keyword">in</span>
                    <span class="type">Button</span>(peer.<span class="property">displayName</span>) {
                        rpsSession.<span class="property">serviceBrowser</span>.<span class="call">invitePeer</span>(peer, to: rpsSession.<span class="property">session</span>, withContext: <span class="keyword">nil</span>, timeout: <span class="number">30</span>)
                    }
                }
            }
            .<span class="call">alert</span>(<span class="string">"Received an invite from</span> \(rpsSession.<span class="property">recvdInviteFrom</span>?.<span class="property">displayName</span> ?? <span class="string">"ERR"</span>)<span class="string">!"</span>, isPresented: <span class="property">$rpsSession</span>.<span class="property">recvdInvite</span>) {
                <span class="type">Button</span>(<span class="string">"Accept invite"</span>) {
                    <span class="keyword">if</span> (rpsSession.<span class="property">invitationHandler</span> != <span class="keyword">nil</span>) {
                        rpsSession.<span class="property">invitationHandler</span>!(<span class="keyword">true</span>, rpsSession.<span class="property">session</span>)
                    }
                }
                <span class="type">Button</span>(<span class="string">"Reject invite"</span>) {
                    <span class="keyword">if</span> (rpsSession.<span class="property">invitationHandler</span> != <span class="keyword">nil</span>) {
                        rpsSession.<span class="property">invitationHandler</span>!(<span class="keyword">false</span>, <span class="keyword">nil</span>)
                    }
                }
            }
        } <span class="keyword">else</span> {
            <span class="type">GameView</span>(rpsSession: rpsSession)
        }
    }
}
</code></pre><p>The buttons created inside of the List, when pressed, will call invitePeer on our serviceBrowser to send an invitation to the other player. This method is provided by the serviceBrowser and is not implemented by us. The alert listens for changes to the recvdInvite bool in our session object. If the user selects the "Accept invite" button, we call the invitation handler with a true value and our current session. Otherwise, we pass the invitation handler false and don't bother with the session. When either us or the other player receive and accept an invitation, the MCSessionDelegate's "peer didChange" method is called with state being .connected. If you go back and look at that method you'll see we set paired to true which changes the view on screen to the GameView and passes along our rpsSession. That brings us along to the GameView. Since this isn't so much a SwiftUI tutorial and more of a how-to on using Multipeer Connectivity with it, I won't dive too deep into the nitty gritty of my layout since it is pretty wordy. Instead, I'll break down the logic parts and show how I accomplished receiving and sending moves. The layout is comprised of a VStack containing the opponents move (either a thought bubble while the timer counts down or the opponents sent move when the timer expires), a Text that counts down from 10, our current move, and a HStack containing 3 buttons (rock, paper and scissors). Here's the full implementation of GameView:</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">enum</span> Result {
    <span class="keyword">case</span> win, loss, tie
}

<span class="keyword">struct</span> GameView: <span class="type">View</span> {
    <span class="keyword">@StateObject var</span> rpsSession: <span class="type">RPSMultipeerSession</span>
    
    <span class="keyword">@State var</span> timeLeft = <span class="number">10</span>
    <span class="keyword">@State var</span> timer = <span class="type">Timer</span>.<span class="call">publish</span>(every: <span class="number">1</span>, on: .<span class="dotAccess">main</span>, in: .<span class="dotAccess">common</span>).<span class="call">autoconnect</span>()
    
    <span class="keyword">@State var</span> currentMove: <span class="type">Move</span> = .<span class="dotAccess">unknown</span>
    <span class="keyword">@State var</span> opponentMove: <span class="type">Move</span> = .<span class="dotAccess">unknown</span>
    <span class="keyword">@State var</span> showResult: <span class="type">Bool</span> = <span class="keyword">false
    @State var</span> result: <span class="type">Result</span> = .<span class="dotAccess">tie</span>
    <span class="keyword">@State var</span> resultMessage: <span class="type">String</span> = <span class="string">""</span>
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ZStack</span> {
            <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>) {
                <span class="comment">// Opponent - 🪨 📄 ✂️</span>
                <span class="type">Image</span>(opponentMove.<span class="property">description</span>)
                    .<span class="call">resizable</span>()
                    .<span class="call">scaledToFit</span>()
                    .<span class="call">frame</span>(width: <span class="number">100</span>)
                    .<span class="call">padding</span>(.<span class="dotAccess">top</span>)
                    .<span class="call">padding</span>()
                
                <span class="comment">// Timer - 10</span>
                <span class="type">Text</span>(<span class="string">"</span>\(timeLeft)<span class="string">"</span>)
                    .<span class="call">font</span>(.<span class="call">system</span>(size: <span class="number">30</span>))
                    .<span class="call">onReceive</span>(timer) { input <span class="keyword">in
                        if</span> (timeLeft &gt; <span class="number">0</span>) {
                            timeLeft -= <span class="number">1</span>
                        } <span class="keyword">else</span> {
                            timeLeft = <span class="number">10</span>
                            timer.<span class="property">upstream</span>.<span class="call">connect</span>().<span class="call">cancel</span>()
                            <span class="comment">// Call timer.upstream.connect() to restart the timer</span>
                            <span class="keyword">switch</span> rpsSession.<span class="property">receivedMove</span> {
                            <span class="keyword">case</span> .<span class="dotAccess">rock</span>:
                                opponentMove = .<span class="dotAccess">rock</span>
                                <span class="keyword">break
                            case</span> .<span class="dotAccess">paper</span>:
                                opponentMove = .<span class="dotAccess">paper</span>
                                <span class="keyword">break
                            case</span> .<span class="dotAccess">scissors</span>:
                                opponentMove = .<span class="dotAccess">scissors</span>
                                <span class="keyword">break
                            default</span>:
                                <span class="comment">// TODO: Invalid, big red X or something idk</span>
                                opponentMove = .<span class="dotAccess">unknown</span>
                                <span class="keyword">break</span>
                            }
                            <span class="comment">//TODO: Show winning/losing screen and restart button</span>
                            result = <span class="call">score</span>(opponentMove: opponentMove, ourMove: currentMove)
                            <span class="keyword">if</span> (result == .<span class="dotAccess">win</span>) {
                                resultMessage = <span class="string">"You won!"</span>
                            } <span class="keyword">else if</span> (result == .<span class="dotAccess">loss</span>) {
                                resultMessage = <span class="string">"You lost!"</span>
                            } <span class="keyword">else</span> {
                                resultMessage = <span class="string">"It's a tie!"</span>
                            }
                            showResult = <span class="keyword">true</span>
                        }
                    }
                <span class="comment">// Player - Move</span>
                <span class="type">Image</span>(currentMove.<span class="property">description</span>)
                    .<span class="call">resizable</span>()
                    .<span class="call">scaledToFit</span>()
                    .<span class="call">frame</span>(width: <span class="number">100</span>)
                    .<span class="call">padding</span>()
                    .<span class="call">padding</span>(.<span class="dotAccess">bottom</span>, <span class="number">20</span>)
                <span class="comment">// Moves - Moves</span>
                <span class="type">HStack</span> {
                    <span class="type">Button</span>(action: {
                        currentMove = .<span class="dotAccess">rock</span>
                        rpsSession.<span class="call">send</span>(move: .<span class="dotAccess">rock</span>)
                    }, label: {
                        <span class="type">Image</span>(<span class="string">"Rock"</span>)
                            .<span class="call">resizable</span>()
                            .<span class="call">scaledToFit</span>()
                            .<span class="call">frame</span>(width: <span class="number">40</span>)
                    })
                        .<span class="call">buttonStyle</span>(<span class="type">BorderlessButtonStyle</span>())
                        .<span class="call">padding</span>()
                    
                    <span class="type">Button</span>(action: {
                        currentMove = .<span class="dotAccess">paper</span>
                        rpsSession.<span class="call">send</span>(move: .<span class="dotAccess">paper</span>)
                    }, label: {
                        <span class="type">Image</span>(<span class="string">"Paper"</span>)
                            .<span class="call">resizable</span>()
                            .<span class="call">scaledToFit</span>()
                            .<span class="call">frame</span>(width: <span class="number">40</span>)
                    })
                        .<span class="call">buttonStyle</span>(<span class="type">BorderlessButtonStyle</span>())
                        .<span class="call">padding</span>()
                    
                    <span class="type">Button</span>(action: {
                        currentMove = .<span class="dotAccess">scissors</span>
                        rpsSession.<span class="call">send</span>(move: .<span class="dotAccess">scissors</span>)
                    }, label: {
                        <span class="type">Image</span>(<span class="string">"Scissors"</span>)
                            .<span class="call">resizable</span>()
                            .<span class="call">scaledToFit</span>()
                            .<span class="call">frame</span>(width: <span class="number">40</span>)
                    })
                        .<span class="call">buttonStyle</span>(<span class="type">BorderlessButtonStyle</span>())
                        .<span class="call">padding</span>()
                }
            }
            <span class="keyword">if</span> (showResult) {
                <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">10</span>) {
                    <span class="type">Text</span>(resultMessage)
                        .<span class="call">fontWeight</span>(.<span class="dotAccess">heavy</span>)
                    <span class="type">Text</span>(<span class="string">"Would you like to play again?"</span>)
                        .<span class="call">fontWeight</span>(.<span class="dotAccess">regular</span>)
                    <span class="type">Button</span>(<span class="string">"Yes"</span>) {
                        showResult = <span class="keyword">false</span>
                        <span class="comment">//TODO: Send restart message to peer, wait for response</span>
                    }
                    <span class="type">Button</span>(<span class="string">"No"</span>) {
                        rpsSession.<span class="property">session</span>.<span class="call">disconnect</span>()
                    }
                }.<span class="call">zIndex</span>(<span class="number">1</span>)
                    .<span class="call">frame</span>(width: <span class="number">400</span>, height: <span class="number">500</span>)
                    .<span class="call">background</span>(<span class="type">Color</span>.<span class="property">white</span>)
                    .<span class="call">cornerRadius</span>(<span class="number">12</span>)
            }
        }
    }
    
    <span class="keyword">func</span> score(opponentMove: <span class="type">Move</span>, ourMove: <span class="type">Move</span>) -&gt; <span class="type">Result</span> {
        <span class="keyword">switch</span> opponentMove {
        <span class="keyword">case</span> .<span class="dotAccess">rock</span>:
            <span class="keyword">if</span> ourMove == .<span class="dotAccess">scissors</span> {
                <span class="keyword">return</span> .<span class="dotAccess">loss</span>
            } <span class="keyword">else if</span> ourMove == .<span class="dotAccess">paper</span> {
                <span class="keyword">return</span> .<span class="dotAccess">win</span>
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> .<span class="dotAccess">tie</span>
            }
        <span class="keyword">case</span> .<span class="dotAccess">paper</span>:
            <span class="keyword">if</span> ourMove == .<span class="dotAccess">rock</span> {
                <span class="keyword">return</span> .<span class="dotAccess">loss</span>
            } <span class="keyword">else if</span> ourMove == .<span class="dotAccess">scissors</span> {
                <span class="keyword">return</span> .<span class="dotAccess">win</span>
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> .<span class="dotAccess">tie</span>
            }
        <span class="keyword">case</span> .<span class="dotAccess">scissors</span>:
            <span class="keyword">if</span> ourMove == .<span class="dotAccess">paper</span> {
                <span class="keyword">return</span> .<span class="dotAccess">loss</span>
            } <span class="keyword">else if</span> ourMove == .<span class="dotAccess">rock</span> {
                <span class="keyword">return</span> .<span class="dotAccess">win</span>
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> .<span class="dotAccess">tie</span>
            }
        <span class="keyword">default</span>:
            <span class="comment">// Invalid move somewhere</span>
            <span class="keyword">return</span> .<span class="dotAccess">tie</span>
        }
    }
}
</code></pre><p>You can see the timer updates every second and, when it reaches zero, checks if we received a move from our opponent to score and announce a winner. Every time a move button is pressed, we set currentMove, which then updates the image on our current move, and send the move to our opponent. This implementation is fine. It does what I wanted and finally we can use MPC with SwiftUI 4 without the need for any UIKit garbage (sorry). But it isn't perfect. Aside from the obvious issues with error handling, ugly UI elements, lack of communication with the user regarding a rejected invitation, no implemented way to restart or leave a game, etc., the main issue with my implementation is the Timer. The timers will often go out of sync since the timer on the device that received the invitation will start a fraction of a second before the timer on the device that sent the invitation (it knows the invitation was accepted first, after all). I have a few ideas to fix this issue. I believe the best solution would be to have the device that starts the game (the one that accepts the invitation) stream the timer to the other device after the other device has switched to the game view. Basically once the game view is shown, the second device would send a message to the first one notifying it to start streaming the timer. That might be better but it also might have the same issue and it seems a little bit overkill. The delay in the timer is not a huge deal considering the players wouldn't be looking at each others' screens anyway or else what would be the point? But for fun, I'm going to sit up and try and get my stream implementation working. It might be worth it to learn about how data is streamed over MPC for future projects. When I'm done tackling that I'll post a follow-up here and plan on making a full step-by-step youtube tutorial. Thanks for reading and leave some comments if you have some suggestions or noticed something I missed!</p>]]></content:encoded></item></channel></rss>