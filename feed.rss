<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Joe's Blog</title><description>A cautionary tale on the horrors of programming ‚ù§Ô∏è</description><link>https://www.jdiggity.me</link><language>en</language><lastBuildDate>Sat, 13 Aug 2022 03:51:30 +0000</lastBuildDate><pubDate>Sat, 13 Aug 2022 03:51:30 +0000</pubDate><ttl>250</ttl><atom:link href="https://www.jdiggity.me/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.jdiggity.me/posts/mpc-2</guid><title>mpc-2</title><description></description><link>https://www.jdiggity.me/posts/mpc-2</link><pubDate>Sat, 13 Aug 2022 03:51:14 +0000</pubDate><content:encoded><![CDATA[]]></content:encoded></item><item><guid isPermaLink="true">https://www.jdiggity.me/posts/publish-ghactions</guid><title>Using GitHub actions to deploy Publish sites to GitHub Pages</title><description>How to use GitHub Actions to deploy a static site built with Publish to GitHub Pages</description><link>https://www.jdiggity.me/posts/publish-ghactions</link><pubDate>Tue, 9 Aug 2022 18:32:00 +0000</pubDate><content:encoded><![CDATA[<h1>Using GitHub actions to deploy Publish sites to GitHub Pages</h1><p>I just spent a good few weeks looking for a good static site generator and in my journey found <a href="https://github.com/JohnSundell/Publish">Publish</a>. While this article isn‚Äôt about that, I highly recommend using Publish if you‚Äôre a Swift developer looking for a good static site generator!</p><p>While <code>Publish</code> comes with a built-in deployment function that works with GH Pages, <em>I</em> couldn't get it to work. It looks like it really only works if you‚Äôre deploying to a separate repository. Even then, a lot of us wish to automatically trigger a publish on each new blog post or git commit. I spent some time yesterday messing with GitHub Actions and put together a build script that can do just that.</p><h2>The Process</h2><p>I started off trying to simply spin up a macOS machine, cloning my repo, installing the <code>publish</code> command line tool from homebrew, generating the HTML and pushing that to my GitHub Pages branch.</p><p>This proved to be a bit of a hassle. GitHub actions uses a version of macOS that is too old to work with the publish command line tool that is available through homebrew.</p><p>‚ÄúOkay,‚Äù I thought. ‚ÄúI‚Äôll just build the command line tool from the source code.‚Äù Well, that didn‚Äôt work either. I was missing some swift concurrency libraries on the worker machine. That meant, I assume, the version of Swift on the GH Actions build machine was too old ‚òπÔ∏è.</p><p>At this point I considered giving up, until I remembered Swift is cross platform! üéâüéâ</p><p>I set the runner to use <code>ubuntu-latest</code> instead of <code>macOS-latest</code> and got to thinking.</p><p>On Ubuntu the steps would be a bit different. First and foremost I‚Äôd need to install Swift. Luckily there exists an action on the GitHub Actions Marketplace called <a href="https://github.com/marketplace/actions/install-swift-on-linux"><code>Install Swift on Linux</code></a> which does just that: installs Swift on a Linux worker on Github Actions! Lucky day!</p><p>After Swift was installed I‚Äôd need to either get the <code>publish</code> command line tool building on Linux or figure out a way to build the project some other way. ü§û</p><p>Luckily (spoiler alert) the <code>publish</code> tool compiled and installed just fine on Ubuntu.</p><p>The last step was to push the resulting <code>Output</code> directory to my GitHub pages branch on my repo. Luckily there exists an awesome action on the GitHub Marketplace that makes doing that extremely easy. It‚Äôs called <a href="https://github.com/marketplace/actions/deploy-to-github-pages">Deploy to GitHub Pages</a> and it works like a charm!</p><p>Now that we‚Äôve outlined the approach let‚Äôs get to making the workflow!</p><h2>Before we start...</h2><p>This will <em>not</em> be a GitHub Pages tutorial. In order to follow along here, you should already have GitHub Pages setup using one of your repos. You can check out the <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site">Creating a GitHub Pages Site</a> article for more info. Basically you'll create a new repository, name it <code>&lt;yourgithubusername&gt;.github.io</code> and configure the settings there.</p><h2>Creating the Workflow</h2><p>To get started creating the workflow we‚Äôll open up a terminal and <code>cd</code> into our project‚Äôs root directory.</p><p>Once there, we create the directory <code>.github/workflows</code> and create a new file inside there called <code>main.yml</code>.</p><pre><code><span class="keyword">mkdir</span> <span class="type">-p</span> <span class="string">.github/workflows</span><br /><span class="keyword">touch</span> <span class="string">.github/workflows/main.yml</span></code></pre><p>Now we open up our favorite text editor and start configuring our workflow!</p><pre><code><span class="keyword">nvim</span> <span class="string">.github/workflows/main.yml</span></code></pre><p>First, we name our workflow:</p><pre><code><span class="type">name</span>: <span class="string">Deploy to GitHub Pages</span></code></pre><p>Next, we trigger the workflow when the branch with our source code receives a push. In my case, the source code for my blog is located on the <code>Publish</code> branch.</p><pre><code><span class="type">on</span>:<br />  <span class="type">push</span>:<br />    <span class="type">branches</span>: [ <span class="string">‚ÄúPublish‚Äù</span> ]</code></pre><p>Finally we begin the actual workflow. First we tell the worker to use <code>ubuntu-latest</code> and use the marketplace action mentioned above to install the latest version of <code>Swift</code>.</p><pre><code><span class="type">jobs</span>:<br />  <span class="type">build</span>:<br />    <span class="type">runs-on</span>: <span class="string">ubuntu-latest</span><br />    <span class="type">steps</span>:<br />      - <span class="type">name</span>: <span class="string">Install Swift</span><br />        <span class="type">uses</span>: <span class="string">sersoft-gmbh/swifty-linux-action@v1</span><br />        <span class="type">with</span>:<br />          <span class="type">release-version</span>: <span class="string">5.6.2</span></code></pre><p>With our worker configured and swift installed we can move on to the next step: installing the <code>publish</code> command line tool.</p><p>Inside of the <code>steps</code> section we add the following:</p><pre><code>- <span class="type">name</span>: <span class="string">Install Publish</span><br />  <span class="type">run</span>: <span class="keyword">|</span><br /><span class="string">    git clone https://github.com/JohnSundell/Publish.git<br />    cd Publish<br />    make</span></code></pre><p>Now we can pull our repo to the worker and generate our static website!</p><pre><code>- <span class="type">uses</span>: <span class="string">actions/checkout@v3</span><br /><br />- <span class="type">name</span>: <span class="string">Generate site</span>
  <span class="type">run</span>: <span class="keyword">|</span><br /><span class="string">    cd $GITHUB_WORKSPACE/blog/<br />    publish generate</span></code></pre><p>A few things are going on here. First we use the <code>checkout</code> action from GitHub that pulls our repo from the branch that this <code>main.yml</code> is located on. The <code>checkout</code> action pulls the source code to <code>$GITHUB_WORKSPACE</code>, so we <code>cd</code> to that path. In my case, the source code is located inside of a subdirectory called <code>blog</code>, so I change directories to <code>$GITHUB_WORKSPACE/blog</code>. Once inside that directory we call <code>publish generate</code> to generate our static website.</p><p>Lastly we‚Äôll use the <code>github-pages-deploy-action</code> to deploy our static site to our GitHub Pages branch!</p><pre><code><span class="keyword">-</span> <span class="type">name</span>: <span class="string">Deploy site</span>
  <span class="type">uses</span>: <span class="string">JamesIves/github-pages-deploy-action@v4</span>
    <span class="type">with</span>:
      <span class="type">branch</span>: <span class="string">master</span>
      <span class="type">folder</span>: <span class="string">blog/Output</span>
</code></pre><p>And just like that, our workflow is complete! In the last step we tell the <code>github-pages-deploy-action</code> which branch to deploy to, you might set this to <code>gh-pages</code> depending on your configuration. Then we tell it where our static site is located. In my case it‚Äôs located in the <code>Output</code> folder inside of the <code>blog</code> folder inside of the root of my repo. Yours might just be <code>folder: Output</code>.</p><p>After all of that, your <code>.github/workflows/main.yml</code> file should look something like this:</p><pre><code><span class="type">name</span>: <span class="string">Deploy to GHPages</span>

<span class="type">on</span>:
  <span class="type">push</span>:
    <span class="type">branches</span>: <span class="keyword">[</span> <span class="string">"Publish"</span> <span class="keyword">]</span>

<span class="type">jobs</span>:
  <span class="type">build</span>:
    <span class="type">runs-on</span>: <span class="string">ubuntu-latest</span>
    <span class="type">steps</span>:
      <span class="keyword">-</span> <span class="type">name</span>: <span class="string">Install Swift</span>
        <span class="type">uses</span>: <span class="string">sersoft-gmbh/swifty-linux-action@v1</span>
        <span class="type">with</span>:
          <span class="type">release-version</span>: <span class="string">5.6.2</span>

      <span class="keyword">-</span> <span class="type">name</span>: <span class="string">Install Publish</span>
        <span class="type">run</span>: <span class="keyword">|</span>
          <span class="string">git clone https://github.com/JohnSundell/Publish.git
          cd Publish
          make</span>

      <span class="keyword">-</span> <span class="type">uses</span>: <span class="string">actions/checkout@v3</span>

      <span class="keyword">-</span> <span class="type">name</span>: <span class="string">Generate site</span>
        <span class="type">run</span>: <span class="keyword">|</span>
          <span class="string">cd $GITHUB_WORKSPACE/blog/
          publish generate</span>

      <span class="keyword">-</span> <span class="type">name</span>: <span class="string">Publish site</span>
        <span class="type">uses</span>: <span class="string">JamesIves/github-pages-deploy-action@v4</span>
        <span class="type">with</span>:
          <span class="type">branch</span>: <span class="string">master</span>
          <span class="type">folder</span>: <span class="string">blog/Output</span>
</code></pre><p>Now commit and push that file to your repo and go to the <code>actions</code> tab.</p><img src="https://www.jdiggity.me/img/ghactions.png" alt="GitHub Actions"/>]]></content:encoded></item><item><guid isPermaLink="true">https://www.jdiggity.me/posts/mpc-1</guid><title>Using the Multipeer Connectivity Framework with SwiftUI 4</title><description>How I got the multipeer connectivity framework working with SwiftUI 4</description><link>https://www.jdiggity.me/posts/mpc-1</link><pubDate>Sun, 7 Aug 2022 18:32:00 +0000</pubDate><content:encoded><![CDATA[<h1>Using the Multipeer Connectivity Framework with SwiftUI 4</h1><p>Welcome to my first SwiftUI tutorial! In this one, I‚Äôm going to be demonstrating how to implement a basic Multipeer connectivity app that uses SwiftUI 4, no UIKit needed!</p><p>Without further ado, let‚Äôs begin!</p><p>The basic structure of our app will be as follows:</p><ul><li>A MultipeerSession object to handle pairing and communication with our paired peer</li><li>PairView will show the user a list of available peers and allow them to invite them to a game</li><li>GameView will display the game controls and show the user if they‚Äôve won or lost</li></ul><p>The game will be a basic ‚ÄúRock, Paper, Scissors‚Äù game. The users will pair up with each other, then they will be shown three options, rock, paper or scissors. When the user selects a move it will be sent to the opponent‚Äôs device, and once the timer is up the result will be shown.</p><p>With that basic overview out of the way, let‚Äôs dive into some code.</p><p>We‚Äôll start by creating the MultipeerSession object. First, we need to import MultipeerConnectivity into our class and inherit NSObject and ObrvableObject.</p><pre><code><span class="keyword">class</span> RPSMultipeerSession: <span class="type">NSObject</span>, <span class="type">ObservableObject</span> {
    <span class="keyword">private let</span> serviceType = <span class="string">"rps-service"</span>
    <span class="keyword">private var</span> myPeerID: <span class="type">MCPeerID</span>
    
    <span class="keyword">public let</span> serviceAdvertiser: <span class="type">MCNearbyServiceAdvertiser</span>
    <span class="keyword">public let</span> serviceBrowser: <span class="type">MCNearbyServiceBrowser</span>
    <span class="keyword">public let</span> session: <span class="type">MCSession</span>
}
</code></pre><p>Here we create a <code>serviceType</code> string that will let other devices scanning for peers know that we are using the <code>RPS</code> app and are looking for <code>RPS</code> peers only. This string can be anything to distinguish our Multipeer service from others. We then create some instance variables that hold our <code>MCPeerID</code>, <code>MCNearbyServiceAdvertiser</code>, <code>MCNearbyServiceBrowser</code> and <code>MCSession</code>. These fields need to be made public so that we can perform operations with them outside of the <code>RPSMultipeerSession</code> class.</p><p>Inside of our object‚Äôs <code>init()</code> we will need to assign values to the variables we created above.</p><pre><code><span class="keyword">init</span>(username: <span class="type">String</span>) {
    myPeerID = <span class="type">MCPeerID</span>(displayName: username)
        
    session = <span class="type">MCSession</span>(peer: peerID, securityIdentity: <span class="keyword">nil</span>, encryptionPreference: .<span class="dotAccess">none</span>)
    serviceAdvertiser = <span class="type">MCNearbyServiceAdvertiser</span>(peer: peerID, discoveryInfo: <span class="keyword">nil</span>, serviceType: serviceType)
    serviceBrowser = <span class="type">MCNearbyServiceBrowser</span>(peer: peerID, serviceType: serviceType)
    <span class="keyword">super</span>.<span class="keyword">init</span>()
}
</code></pre><p>In our app, we‚Äôll be allowing users to create a username to make discovery of peers easier. Here, we take the provided username as an argument in the initializer and create a <code>MCPeerID</code> from it.</p><p>Also inside of the initializer we create:</p><ul><li>session: Used for sending and receiving RPS moves</li><li>serviceAdvertiser: Used for advertising ourself to nearby players</li><li>serviceBrowser: Used for finding available players nearby</li></ul><p>And don‚Äôt forget to call <code>super.init()</code> to call the superclass‚Äô init method!</p><p>Next, we need to consider how the data will be received from our peer. Later, we will create a delegate for our <code>session</code> object that will receive a <code>Data</code> object from our peer that we can then turn into something easier to work with. Since we only really have four options (rock, paper, scissors and none), we will be using an <code>enum</code> to make dealing with responses more readable and easier to work with. Something like this, placed inside of the same file as our <code>RPSMultipeerSession</code> class, will suffice:</p><pre><code><span class="keyword">enum</span> Move: <span class="type">String</span>, <span class="type">CaseIterable</span>, <span class="type">CustomStringConvertible</span> {
    <span class="keyword">case</span> rock, paper, scissors, unknown
    
    <span class="keyword">var</span> description : <span class="type">String</span> {
        <span class="keyword">switch self</span> {
        <span class="keyword">case</span> .<span class="dotAccess">rock</span>: <span class="keyword">return</span> <span class="string">"Rock"</span>
        <span class="keyword">case</span> .<span class="dotAccess">paper</span>: <span class="keyword">return</span> <span class="string">"Paper"</span>
        <span class="keyword">case</span> .<span class="dotAccess">scissors</span>: <span class="keyword">return</span> <span class="string">"Scissors"</span>
        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">"Thinking"</span>
        }
    }
}
</code></pre><p>Later on we will be using a <code>String</code> representation of our <code>Move</code> to display an image to our player. By using <code>CustomStringConvertible</code> we can reduce the amount of code needed to do just that.</p><p>Now that we have our <code>Move</code> enum created and usable, we should consider what type of data needs to be made available to our views. We know that our <code>PairView</code>, which will allow players to find and pair up with their friends, will need to have access to a list of currently available peers. That same view will need to know when we receive an invite from another player, as well as who that player is. The <code>GameView</code> will need to know when we receive a move from our opponent. More than one of our views might find it useful to know whether or not we are currently paired with a player and, lastly, our <code>PairView</code> will need to have some way of accepting or denying an invitation from another player.</p><pre><code><span class="keyword">@Published var</span> availablePeers: [<span class="type">MCPeerID</span>] = []
<span class="keyword">@Published var</span> receivedMove: <span class="type">Move</span> = .<span class="dotAccess">unknown</span>
<span class="keyword">@Published var</span> recvdInvite: <span class="type">Bool</span> = <span class="keyword">false
@Published var</span> recvdInviteFrom: <span class="type">MCPeerID</span>? = <span class="keyword">nil
@Published var</span> paired: <span class="type">Bool</span> = <span class="keyword">false
@Published var</span> invitationHandler: ((<span class="type">Bool</span>, <span class="type">MCSession</span>?) -&gt; <span class="type">Void</span>)?
</code></pre><p>All together, we will have six <code>@Published</code> properties in our <code>RPSMultipeerSession</code>. Making these variables <code>@Published</code> makes it so that our views can not only see the the value of the variable, but they can be notified when the values change.</p><p>With that out of the way, we need to create some delegates for our <code>session</code>, <code>serviceAdvertiser</code> and <code>serviceBrowser</code>. Let‚Äôs start with the longest one, <code>MCSessionDelegate</code>.</p><p>The session delegate has methods to handle:</p><ul><li>When a peer changes state (connected, disconnected, connecting)</li><li>When we receive <code>Data</code> from a peer</li><li>When we receive an <code>InputStream</code> from a peer</li><li>When we receive a <code>Resource</code> from a peer (with or without progress)</li><li>When we receive a certificate from a peer (authentication)</li></ul><p>We are really only concerned with two of these methods: when a peer changes state and when we receive <code>Data</code> from a user. Even though that is the case, each of these methods needs to be implemented inside of the delegate.</p><p>Swift has a neat feature called <code>extensions</code>. If you are unfamiliar, extensions essentially let you add code to any Swift class. One could create an <code>extension</code> on the <code>String</code> class to perform any kind of operation on a string. <code>Extension</code>s are extremely powerful and I highly recommend looking into the details but for now that should be a sufficient introduction to get us going.</p><p>To prevent our <code>RPSMultipeerSession</code> from getting too big to handle, we will utilize Swift‚Äôs <code>extension</code> to implement these delegates. We can simply do:</p><blockquote><p>extension RPSMultipeerSession: MCSessionDelegate</p></blockquote><p>and implement the delegate functions in there, outside of the main class but still in the same file. One could place these delegates into separate files, but I personally chose to keep them all inside of one file.</p><pre><code><span class="keyword">extension</span> <span class="type">RPSMultipeerSession</span>: <span class="type">MCSessionDelegate</span> {
    <span class="keyword">func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, peer peerID: <span class="type">MCPeerID</span>, didChange state: <span class="type">MCSessionState</span>) {
        log.<span class="call">info</span>(<span class="string">"peer</span> \(peerID) <span class="string">didChangeState:</span> \(state.<span class="property">rawValue</span>)<span class="string">"</span>)
        <span class="keyword">switch</span> state {
        <span class="keyword">case</span> <span class="type">MCSessionState</span>.<span class="property">notConnected</span>:
            <span class="comment">// Peer disconnected</span>
            <span class="keyword">break
        case</span> <span class="type">MCSessionState</span>.<span class="property">connected</span>:
            <span class="comment">// Peer connected</span>
            <span class="keyword">break
        default</span>:
            <span class="comment">// Peer connecting or something else</span>
            <span class="keyword">break</span>
        }
    }
    
    <span class="keyword">func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didReceive data: <span class="type">Data</span>, fromPeer peerID: <span class="type">MCPeerID</span>) {
        <span class="keyword">if let</span> string = <span class="type">String</span>(data: data, encoding: .<span class="dotAccess">utf8</span>), <span class="keyword">let</span> move = <span class="type">Move</span>(rawValue: string) {
            <span class="comment">// Received move from peer</span>
        } <span class="keyword">else</span> {
            log.<span class="call">info</span>(<span class="string">"didReceive invalid value</span> \(data.<span class="property">count</span>) <span class="string">bytes"</span>)
        }
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didReceive stream: <span class="type">InputStream</span>, withName streamName: <span class="type">String</span>, fromPeer peerID: <span class="type">MCPeerID</span>) {
        log.<span class="call">error</span>(<span class="string">"Receiving streams is not supported"</span>)
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didStartReceivingResourceWithName resourceName: <span class="type">String</span>, fromPeer peerID: <span class="type">MCPeerID</span>, with progress: <span class="type">Progress</span>) {
        log.<span class="call">error</span>(<span class="string">"Receiving resources is not supported"</span>)
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didFinishReceivingResourceWithName resourceName: <span class="type">String</span>, fromPeer peerID: <span class="type">MCPeerID</span>, at localURL: <span class="type">URL</span>?, withError error: <span class="type">Error</span>?) {
        log.<span class="call">error</span>(<span class="string">"Receiving resources is not supported"</span>)
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didReceiveCertificate certificate: [<span class="type">Any</span>]?, fromPeer peerID: <span class="type">MCPeerID</span>, certificateHandler: <span class="keyword">@escaping</span> (<span class="type">Bool</span>) -&gt; <span class="type">Void</span>) {
        <span class="call">certificateHandler</span>(<span class="keyword">true</span>)
    }
}
</code></pre><p>Like I said earlier, this is a <em>big</em> one. Make sure to use XCode‚Äôs autocomplete to get the functions declared.</p><p>As you can see, most of the functions simply print a line to the console and don‚Äôt actually do anything at all. This is because our app does not support sending or receiving streams or resources. This may change as the tutorial goes along, though (;</p><p>We‚Äôre not done, yet! If you‚Äôre following along with the code you‚Äôve probably noticed that delegate doesn‚Äôt actually do anything at all. We need to implement the logic for responding to peer connectivity status changes and receiving data from our opponent. I will go in detail in part 2 on how to handle these events, so for now let‚Äôs move on.</p><p>Next we will implement the <code>MCNearbyServiceAdvertiserDelegate</code>. This one is a lot easier to digest:</p><pre><code><span class="keyword">extension</span> <span class="type">RPSMultipeerSession</span>: <span class="type">MCNearbyServiceAdvertiserDelegate</span> {
    <span class="keyword">func</span> advertiser(<span class="keyword">_</span> advertiser: <span class="type">MCNearbyServiceAdvertiser</span>, didNotStartAdvertisingPeer error: <span class="type">Error</span>) {
        log.<span class="call">error</span>(<span class="string">"ServiceAdvertiser didNotStartAdvertisingPeer:</span> \(<span class="type">String</span>(describing: error))<span class="string">"</span>)
    }
    
    <span class="keyword">func</span> advertiser(<span class="keyword">_</span> advertiser: <span class="type">MCNearbyServiceAdvertiser</span>, didReceiveInvitationFromPeer peerID: <span class="type">MCPeerID</span>, withContext context: <span class="type">Data</span>?, invitationHandler: <span class="keyword">@escaping</span> (<span class="type">Bool</span>, <span class="type">MCSession</span>?) -&gt; <span class="type">Void</span>) {
        log.<span class="call">info</span>(<span class="string">"didReceiveInvitationFromPeer</span> \(peerID)<span class="string">"</span>)
    }
}
</code></pre><p>The service advertiser has two methods: one is called when the advertiser can‚Äôt start advertising for some reason and the other when we receive an invitation from another player. The latter will be implemented, again, in part 2! Last but not least we need to implement the <code>MCNearbyServiceBrowserDelegate</code>.</p><pre><code><span class="keyword">extension</span> <span class="type">RPSMultipeerSession</span>: <span class="type">MCNearbyServiceBrowserDelegate</span> {
    <span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, didNotStartBrowsingForPeers error: <span class="type">Error</span>) {
        <span class="comment">//TODO: Tell the user something went wrong and try again</span>
        log.<span class="call">error</span>(<span class="string">"ServiceBroser didNotStartBrowsingForPeers:</span> \(<span class="type">String</span>(describing: error))<span class="string">"</span>)
    }
    
    <span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, foundPeer peerID: <span class="type">MCPeerID</span>, withDiscoveryInfo info: [<span class="type">String</span> : <span class="type">String</span>]?) {
        log.<span class="call">info</span>(<span class="string">"ServiceBrowser found peer:</span> \(peerID)<span class="string">"</span>)
        <span class="comment">// Add the peer to the list of available peers</span>
    }
    
    <span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, lostPeer peerID: <span class="type">MCPeerID</span>) {
        log.<span class="call">info</span>(<span class="string">"ServiceBrowser lost peer:</span> \(peerID)<span class="string">"</span>)
        <span class="comment">// Remove lost peer from list of available peers</span>
    }
}
</code></pre><p>This delegate has methods that are called when:</p><ul><li>The browser does not start browsing for some reason</li><li>The browser found a nearby peer that is advertising our serviceType</li><li>The browser lost a nearby peer that was advertising our serviceType</li></ul><p>Now that we have our delegates setup we can apply them to our <code>session</code>, <code>serviceAdvertiser</code> and <code>serviceBrowser</code>.</p><pre><code>session.<span class="property">delegate</span> = <span class="keyword">self</span>
serviceAdvertiser.<span class="property">delegate</span> = <span class="keyword">self</span>
serviceBrowser.<span class="property">delegate</span> = <span class="keyword">self</span>
                
serviceAdvertiser.<span class="call">startAdvertisingPeer</span>()
serviceBrowser.<span class="call">startBrowsingForPeers</span>()
</code></pre><p>We add this inside of our <code>init()</code> after the call to <code>super.init()</code>. This assigns the delegates and starts advertising and browsing to/for peers. We‚Äôre almost done, but we can‚Äôt forget to tell our advertiser and browser to stop inside of <code>deinit()</code>.</p><pre><code><span class="keyword">deinit</span> {
    serviceAdvertiser.<span class="call">stopAdvertisingPeer</span>()
    serviceBrowser.<span class="call">stopBrowsingForPeers</span>()
}
</code></pre><p>Now that we have all of this done, our <code>RPSMultipeerSession.swift</code> file should look like this:</p><pre><code><span class="comment">//
//  RPSMultipeerSession.swift
//  RPS
//
//  Created by Joe Diragi on 7/28/22.
//</span>

<span class="keyword">import</span> MultipeerConnectivity
<span class="keyword">import</span> os

<span class="keyword">enum</span> Move: <span class="type">String</span>, <span class="type">CaseIterable</span>, <span class="type">CustomStringConvertible</span> {
    <span class="keyword">case</span> rock, paper, scissors, unknown
    
    <span class="keyword">var</span> description : <span class="type">String</span> {
        <span class="keyword">switch self</span> {
        <span class="keyword">case</span> .<span class="dotAccess">rock</span>: <span class="keyword">return</span> <span class="string">"Rock"</span>
        <span class="keyword">case</span> .<span class="dotAccess">paper</span>: <span class="keyword">return</span> <span class="string">"Paper"</span>
        <span class="keyword">case</span> .<span class="dotAccess">scissors</span>: <span class="keyword">return</span> <span class="string">"Scissors"</span>
        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">"Thinking"</span>
        }
      }
}

<span class="keyword">class</span> RPSMultipeerSession: <span class="type">NSObject</span>, <span class="type">ObservableObject</span> {
    <span class="keyword">private let</span> serviceType = <span class="string">"rps-service"</span>
    <span class="keyword">private var</span> myPeerID: <span class="type">MCPeerID</span>
    
    <span class="keyword">public let</span> serviceAdvertiser: <span class="type">MCNearbyServiceAdvertiser</span>
    <span class="keyword">public let</span> serviceBrowser: <span class="type">MCNearbyServiceBrowser</span>
    <span class="keyword">public let</span> session: <span class="type">MCSession</span>
        
    <span class="keyword">private let</span> log = <span class="type">Logger</span>()
    
    <span class="keyword">@Published var</span> availablePeers: [<span class="type">MCPeerID</span>] = []
    <span class="keyword">@Published var</span> receivedMove: <span class="type">Move</span> = .<span class="dotAccess">unknown</span>
    <span class="keyword">@Published var</span> recvdInvite: <span class="type">Bool</span> = <span class="keyword">false
    @Published var</span> recvdInviteFrom: <span class="type">MCPeerID</span>? = <span class="keyword">nil
    @Published var</span> paired: <span class="type">Bool</span> = <span class="keyword">false
    @Published var</span> invitationHandler: ((<span class="type">Bool</span>, <span class="type">MCSession</span>?) -&gt; <span class="type">Void</span>)?
    
    <span class="keyword">init</span>(username: <span class="type">String</span>) {
        <span class="keyword">let</span> peerID = <span class="type">MCPeerID</span>(displayName: username)
        <span class="keyword">self</span>.<span class="property">myPeerID</span> = peerID
        
        session = <span class="type">MCSession</span>(peer: peerID, securityIdentity: <span class="keyword">nil</span>, encryptionPreference: .<span class="dotAccess">none</span>)
        serviceAdvertiser = <span class="type">MCNearbyServiceAdvertiser</span>(peer: peerID, discoveryInfo: <span class="keyword">nil</span>, serviceType: serviceType)
        serviceBrowser = <span class="type">MCNearbyServiceBrowser</span>(peer: peerID, serviceType: serviceType)
        <span class="keyword">super</span>.<span class="keyword">init</span>()
        
        session.<span class="property">delegate</span> = <span class="keyword">self</span>
        serviceAdvertiser.<span class="property">delegate</span> = <span class="keyword">self</span>
        serviceBrowser.<span class="property">delegate</span> = <span class="keyword">self</span>
                
        serviceAdvertiser.<span class="call">startAdvertisingPeer</span>()
        serviceBrowser.<span class="call">startBrowsingForPeers</span>()
    }
    
    <span class="keyword">deinit</span> {
        serviceAdvertiser.<span class="call">stopAdvertisingPeer</span>()
        serviceBrowser.<span class="call">stopBrowsingForPeers</span>()
    }
}

<span class="keyword">extension</span> <span class="type">RPSMultipeerSession</span>: <span class="type">MCSessionDelegate</span> {
    <span class="keyword">func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, peer peerID: <span class="type">MCPeerID</span>, didChange state: <span class="type">MCSessionState</span>) {
        log.<span class="call">info</span>(<span class="string">"peer</span> \(peerID) <span class="string">didChangeState:</span> \(state.<span class="property">rawValue</span>)<span class="string">"</span>)
        <span class="keyword">switch</span> state {
        <span class="keyword">case</span> <span class="type">MCSessionState</span>.<span class="property">notConnected</span>:
            <span class="comment">// Peer disconnected</span>
            <span class="keyword">break
        case</span> <span class="type">MCSessionState</span>.<span class="property">connected</span>:
            <span class="comment">// Peer connected</span>
            <span class="keyword">break
        default</span>:
            <span class="comment">// Peer connecting or something else</span>
            <span class="keyword">break</span>
        }
    }
    
    <span class="keyword">func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didReceive data: <span class="type">Data</span>, fromPeer peerID: <span class="type">MCPeerID</span>) {
        <span class="keyword">if let</span> string = <span class="type">String</span>(data: data, encoding: .<span class="dotAccess">utf8</span>), <span class="keyword">let</span> move = <span class="type">Move</span>(rawValue: string) {
            <span class="comment">// Received move from peer</span>
        } <span class="keyword">else</span> {
            log.<span class="call">info</span>(<span class="string">"didReceive invalid value</span> \(data.<span class="property">count</span>) <span class="string">bytes"</span>)
        }
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didReceive stream: <span class="type">InputStream</span>, withName streamName: <span class="type">String</span>, fromPeer peerID: <span class="type">MCPeerID</span>) {
        log.<span class="call">error</span>(<span class="string">"Receiving streams is not supported"</span>)
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didStartReceivingResourceWithName resourceName: <span class="type">String</span>, fromPeer peerID: <span class="type">MCPeerID</span>, with progress: <span class="type">Progress</span>) {
        log.<span class="call">error</span>(<span class="string">"Receiving resources is not supported"</span>)
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didFinishReceivingResourceWithName resourceName: <span class="type">String</span>, fromPeer peerID: <span class="type">MCPeerID</span>, at localURL: <span class="type">URL</span>?, withError error: <span class="type">Error</span>?) {
        log.<span class="call">error</span>(<span class="string">"Receiving resources is not supported"</span>)
    }
    
    <span class="keyword">public func</span> session(<span class="keyword">_</span> session: <span class="type">MCSession</span>, didReceiveCertificate certificate: [<span class="type">Any</span>]?, fromPeer peerID: <span class="type">MCPeerID</span>, certificateHandler: <span class="keyword">@escaping</span> (<span class="type">Bool</span>) -&gt; <span class="type">Void</span>) {
        <span class="call">certificateHandler</span>(<span class="keyword">true</span>)
    }
}

<span class="keyword">extension</span> <span class="type">RPSMultipeerSession</span>: <span class="type">MCNearbyServiceAdvertiserDelegate</span> {
    <span class="keyword">func</span> advertiser(<span class="keyword">_</span> advertiser: <span class="type">MCNearbyServiceAdvertiser</span>, didNotStartAdvertisingPeer error: <span class="type">Error</span>) {
        log.<span class="call">error</span>(<span class="string">"ServiceAdvertiser didNotStartAdvertisingPeer:</span> \(<span class="type">String</span>(describing: error))<span class="string">"</span>)
    }
    
    <span class="keyword">func</span> advertiser(<span class="keyword">_</span> advertiser: <span class="type">MCNearbyServiceAdvertiser</span>, didReceiveInvitationFromPeer peerID: <span class="type">MCPeerID</span>, withContext context: <span class="type">Data</span>?, invitationHandler: <span class="keyword">@escaping</span> (<span class="type">Bool</span>, <span class="type">MCSession</span>?) -&gt; <span class="type">Void</span>) {
        log.<span class="call">info</span>(<span class="string">"didReceiveInvitationFromPeer</span> \(peerID)<span class="string">"</span>)
    }
}

<span class="keyword">extension</span> <span class="type">RPSMultipeerSession</span>: <span class="type">MCNearbyServiceBrowserDelegate</span> {
    <span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, didNotStartBrowsingForPeers error: <span class="type">Error</span>) {
        <span class="comment">//TODO: Tell the user something went wrong and try again</span>
        log.<span class="call">error</span>(<span class="string">"ServiceBroser didNotStartBrowsingForPeers:</span> \(<span class="type">String</span>(describing: error))<span class="string">"</span>)
    }
    
    <span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, foundPeer peerID: <span class="type">MCPeerID</span>, withDiscoveryInfo info: [<span class="type">String</span> : <span class="type">String</span>]?) {
        log.<span class="call">info</span>(<span class="string">"ServiceBrowser found peer:</span> \(peerID)<span class="string">"</span>)
        <span class="comment">// Add the peer to the list of available peers</span>
    }
    
    <span class="keyword">func</span> browser(<span class="keyword">_</span> browser: <span class="type">MCNearbyServiceBrowser</span>, lostPeer peerID: <span class="type">MCPeerID</span>) {
        log.<span class="call">info</span>(<span class="string">"ServiceBrowser lost peer:</span> \(peerID)<span class="string">"</span>)
        <span class="comment">// Remove lost peer from list of available peers</span>
    }
}
</code></pre><p><a href="https://github.com/TheNightmanCodeth/RPS">Don't forget to check out the GitHub repo!</a></p><p><a href="https://www.jdiggity.me/mpc-2">Continue to part 2</a></p>]]></content:encoded></item></channel></rss>